<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>代码风格指南 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="http://docs.juliacn.com/latest/manual/style-guide/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">起步</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数与分数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li class="current"><a class="toctext" href>代码风格指南</a><ul class="internal"><li><a class="toctext" href="#写函数，而不是仅仅写脚本-1">写函数，而不是仅仅写脚本</a></li><li><a class="toctext" href="#避免写过于特定的类型-1">避免写过于特定的类型</a></li><li><a class="toctext" href="#让调用者处理多余的参数多样性-1">让调用者处理多余的参数多样性</a></li><li><a class="toctext" href="#在会修改自身参数的函数名字后加-!-1">在会修改自身参数的函数名字后加 <code>!</code></a></li><li><a class="toctext" href="#避免使用奇怪的-Union-类型-1">避免使用奇怪的 <code>Union</code> 类型</a></li><li><a class="toctext" href="#避免复杂的容器类型-1">避免复杂的容器类型</a></li><li><a class="toctext" href="#使用和-Julia-的-base/-一致的命名习惯-1">使用和 Julia 的 <code>base/</code> 一致的命名习惯</a></li><li><a class="toctext" href="#使用与-Julia-的-Base-模块类似的参数顺序-1">使用与 Julia 的 Base 模块类似的参数顺序</a></li><li><a class="toctext" href="#不要过度使用-try-catch-1">不要过度使用 try-catch</a></li><li><a class="toctext" href="#不要给条件语句加括号-1">不要给条件语句加括号</a></li><li><a class="toctext" href="#不要过度使用-...-1">不要过度使用 <code>...</code></a></li><li><a class="toctext" href="#不要使用不必要的静态参数-1">不要使用不必要的静态参数</a></li><li><a class="toctext" href="#避免判断变量是实例还是类型的混乱-1">避免判断变量是实例还是类型的混乱</a></li><li><a class="toctext" href="#不要过度使用宏-1">不要过度使用宏</a></li><li><a class="toctext" href="#不要把不安全的操作暴露在接口层-1">不要把不安全的操作暴露在接口层</a></li><li><a class="toctext" href="#不要重载基础容器类型的方法-1">不要重载基础容器类型的方法</a></li><li><a class="toctext" href="#避免类型盗版-1">避免类型盗版</a></li><li><a class="toctext" href="#注意类型相等-1">注意类型相等</a></li><li><a class="toctext" href="#不要写-x-f(x)-1">不要写 <code>x-&gt;f(x)</code></a></li><li><a class="toctext" href="#尽可能避免使用浮点数作为通用代码的字面量-1">尽可能避免使用浮点数作为通用代码的字面量</a></li></ul></li></ul></li><li><span class="toctext">基础组件</span><ul><li><a class="toctext" href="../../base/base/">重要组件</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">数组</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O 和网络（Network）</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">中文文档开发</span><ul><li><a class="toctext" href="../../juliacn/style-guide/">翻译格式指引</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>代码风格指南</a></li></ul><a class="edit-page" href="https://github.com/findmyway/JuliaZH.jl/blob/master/docs/src/manual/style-guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>代码风格指南</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="代码风格指南-1" href="#代码风格指南-1">代码风格指南</a></h1><!-- # Style Guide --><p>接下来的部分将介绍如何写出具有Julia风格的代码。当然，这些规则并不是绝对的，它们只是一些建议，以便更好地帮助你熟悉这门语言，以及在不同的代码设计中做出选择。</p><!-- The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs. --><h2><a class="nav-anchor" id="写函数，而不是仅仅写脚本-1" href="#写函数，而不是仅仅写脚本-1">写函数，而不是仅仅写脚本</a></h2><!-- ## Write functions, not just scripts --><p>一开始解决问题的时候，直接从最外层一步步写代码的确很便捷，但你应该尽早地将代码组织成函数。函数有更强的复用性和可测试性，并且能更清楚地让人知道哪些步骤做完了，以及每一步骤的输入输出分别是什么。此外，由于Julia编译器特殊的工作方式，写在函数中的代码往往要比最外层的代码运行地快得多。</p><!-- Writing code as a series of steps at the top level is a quick way to get started solving a problem,
but you should try to divide a program into functions as soon as possible. Functions are more
reusable and testable, and clarify what steps are being done and what their inputs and outputs
are. Furthermore, code inside functions tends to run much faster than top level code, due to how
Julia's compiler works. --><p>此外值得一提的是，函数应当接受参数，而不是直接使用全局变量（ <a href="../../base/numbers/#Base.MathConstants.pi"><code>pi</code></a> 等常数除外）进行操作。</p><!-- It is also worth emphasizing that functions should take arguments, instead of operating directly
on global variables (aside from constants like [`pi`](@ref)). --><h2><a class="nav-anchor" id="避免写过于特定的类型-1" href="#避免写过于特定的类型-1">避免写过于特定的类型</a></h2><!-- ## Avoid writing overly-specific types --><p>代码应该写得尽可能通用。例如，下面这段代码:</p><!-- Code should be as generic as possible. Instead of writing: --><pre><code class="language-julia">convert(Complex{Float64}, x)</code></pre><p>更好的写法是写成下面的通用函数：</p><!-- it's better to use available generic functions: --><pre><code class="language-julia">complex(float(x))</code></pre><p>上面的版本会把 <code>x</code> 转换成一个合适的类型，而非总是同一类型。</p><!-- The second version will convert `x` to an appropriate type, instead of always the same type. --><p>这种代码风格与函数的参数尤其相关。例如，当一个参数可以是任何整型时，不要将它的类型声明为 <code>Int</code> 或 <a href="../../base/numbers/#Core.Int32"><code>Int32</code></a>，而要使用抽象类型（abstract type）<a href="../../base/numbers/#Core.Integer"><code>Integer</code></a> 来表示。事实上，除非确实需要将其与其它的方法定义区分开，很多情况下你可以干脆完全省略掉参数的类型，因为如果你的操作中有不支持某种参数类型的操作的话，反正都会抛出 <a href="../../base/base/#Core.MethodError"><code>MethodError</code></a> 的。这也称作 <a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型</a>）。</p><!-- This style point is especially relevant to function arguments. For example, don't declare an argument
to be of type `Int` or [`Int32`](@ref) if it really could be any integer, expressed with the abstract
type [`Integer`](@ref). In fact, in many cases you can omit the argument type altogether,
unless it is needed to disambiguate from other method definitions, since a
[`MethodError`](@ref) will be thrown anyway if a type is passed that does not support any
of the requisite operations. (This is known as
[duck typing](https://en.wikipedia.org/wiki/Duck_typing).) --><p>例如，考虑这样的一个叫做 <code>addone</code> 的函数，其返回值为它的参数加 1 ：</p><!-- For example, consider the following definitions of a function `addone` that returns one plus its
argument: --><pre><code class="language-julia">addone(x::Int) = x + 1                 # works only for Int
addone(x::Integer) = x + oneunit(x)    # any integer type
addone(x::Number) = x + oneunit(x)     # any numeric type
addone(x) = x + oneunit(x)             # any type supporting + and oneunit</code></pre><p>最后一种定义可以处理所有支持 <a href="../../base/numbers/#Base.oneunit"><code>oneunit</code></a> （返回和 <code>x</code> 相同类型的 1，以避免不需要的类型提升（type promotion））以及 <a href="../../base/math/#Base.:+"><code>+</code></a> 函数的类型。这里的关键点在于，<strong>只</strong>定义通用的 <code>addone(x) = x + oneunit(x)</code> 并<strong>不会</strong>带来性能上的损失，因为 Julia 会在需要的时候自动编译特定的版本。比如说，当第一次调用 <code>addone(12)</code> 时，Julia 会自动编译一个特定的 <code>addone</code> 函数，它接受一个 <code>x::Int</code> 的参数，并把调用的 <code>oneunit</code> 替换为内连的值 <code>1</code>。因此，上述的前三种 <code>addone</code> 的定义对于第四种来说是完全多余的。</p><!-- The last definition of `addone` handles any type supporting [`oneunit`](@ref) (which returns 1 in
the same type as `x`, which avoids unwanted type promotion) and the [`+`](@ref) function with
those arguments. The key thing to realize is that there is *no performance penalty* to defining
*only* the general `addone(x) = x + oneunit(x)`, because Julia will automatically compile specialized
versions as needed. For example, the first time you call `addone(12)`, Julia will automatically
compile a specialized `addone` function for `x::Int` arguments, with the call to `oneunit`
replaced by its inlined value `1`. Therefore, the first three definitions of `addone` above are
completely redundant with the fourth definition. --><h2><a class="nav-anchor" id="让调用者处理多余的参数多样性-1" href="#让调用者处理多余的参数多样性-1">让调用者处理多余的参数多样性</a></h2><!-- ## Handle excess argument diversity in the caller --><p>如下的代码：</p><!-- Instead of: --><pre><code class="language-julia">function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)</code></pre><p>请写成这样：</p><!-- use: --><pre><code class="language-julia">function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))</code></pre><p>这种风格更好，因为 <code>foo</code> 函数其实不需要接受所有类型的数，而只需要接受 <code>Int</code>。</p><!-- This is better style because `foo` does not really accept numbers of all types; it really needs
`Int` s. --><p>这里的关键在于，如果一个函数需要处理的是整数，强制让调用者来决定非整数如何被转换（比如说向下还是向上取整）会更好。同时，把类型声明得具体一些的话可以为以后的方法定义留有更多的空间。</p><!-- One issue here is that if a function inherently requires integers, it might be better to force
the caller to decide how non-integers should be converted (e.g. floor or ceiling). Another issue
is that declaring more specific types leaves more "space" for future method definitions. --><h2><a class="nav-anchor" id="在会修改自身参数的函数名字后加-!-1" href="#在会修改自身参数的函数名字后加-!-1">在会修改自身参数的函数名字后加 <code>!</code></a></h2><!-- ## Append `!` to names of functions that modify their arguments --><p>如下的代码：</p><!-- Instead of: --><pre><code class="language-julia">function double(a::AbstractArray{&lt;:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end</code></pre><p>请写成这样：</p><!-- use: --><pre><code class="language-julia">function double!(a::AbstractArray{&lt;:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end</code></pre><p>Julia 的 Base 模块中的函数都遵循了这种规范，且包含很多例子：有的函数同时有拷贝和修改的形式（比如 <a href="../../base/sort/#Base.sort"><code>sort</code></a> 和 <a href="../../base/sort/#Base.sort!"><code>sort!</code></a>），还有一些只有修改（比如 <a href="../../base/collections/#Base.push!"><code>push!</code></a>，<a href="../../base/collections/#Base.pop!"><code>pop!</code></a> 和 <a href="../../base/collections/#Base.splice!"><code>splice!</code></a>）。为了方便起见，这类函数通常也会把修改后的数组作为返回值。</p><!-- Julia Base uses this convention throughout and contains examples of functions
with both copying and modifying forms (e.g., [`sort`](@ref) and [`sort!`](@ref)), and others
which are just modifying (e.g., [`push!`](@ref), [`pop!`](@ref), [`splice!`](@ref)).  It
is typical for such functions to also return the modified array for convenience. --><h2><a class="nav-anchor" id="避免使用奇怪的-Union-类型-1" href="#避免使用奇怪的-Union-类型-1">避免使用奇怪的 <code>Union</code> 类型</a></h2><!-- ## Avoid strange type `Union`s --><p>使用 <code>Union{Function,AbstractString}</code> 这样的类型的时候通常意味着设计还不够清晰。</p><!-- Types such as `Union{Function,AbstractString}` are often a sign that some design could be cleaner. --><h2><a class="nav-anchor" id="避免复杂的容器类型-1" href="#避免复杂的容器类型-1">避免复杂的容器类型</a></h2><!-- ## Avoid elaborate container types --><p>像下面这样构造数组通常并没有什么好处：</p><!-- It is usually not much help to construct arrays like the following: --><pre><code class="language-julia">a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)</code></pre><p>这种情况下，<code>Vector{Any}(undef, n)</code>更合适些。此外，相比将所有可能的类型都打包在一起，直接在使用时标注具体的数据类型（比如：<code>a[i]::Int</code>）对编译器来说更有用。</p><!-- In this case `Vector{Any}(undef, n)` is better. It is also more helpful to the compiler to annotate specific
uses (e.g. `a[i]::Int`) than to try to pack many alternatives into one type. --><h2><a class="nav-anchor" id="使用和-Julia-的-base/-一致的命名习惯-1" href="#使用和-Julia-的-base/-一致的命名习惯-1">使用和 Julia 的 <code>base/</code> 一致的命名习惯</a></h2><!-- ## Use naming conventions consistent with Julia's `base/` --><ul><li>模块和类型名使用大写开头的驼峰命名法：<code>module SparseArrays</code>，<code>struct UnitRange</code>。</li><li>函数名使用小写字母，且当可读时可以将多个单词拼在一起。必要的时候，可以使用下划线作为单词分隔符。下划线也被用于指明概念的组合（比如 <a href="manual/@ref"><code>remotecall_fetch</code></a> 作为 <code>fetch(remotecall(...))</code> 的一个更高效的实现）或者变化。</li><li>虽然简洁性很重要，但避免使用缩写（用 <a href="../../base/collections/#Base.indexin"><code>indexin</code></a> 而不是 <code>indxin</code>），因为这会让记住单词有没有被缩写或如何被缩写变得十分困难。</li></ul><!-- * modules and type names use capitalization and camel case: `module SparseArrays`, `struct UnitRange`.
  * functions are lowercase ([`maximum`](@ref), [`convert`](@ref)) and, when readable, with multiple
    words squashed together ([`isequal`](@ref), [`haskey`](@ref)). When necessary, use underscores
    as word separators. Underscores are also used to indicate a combination of concepts ([`remotecall_fetch`](@ref)
    as a more efficient implementation of `fetch(remotecall(...))`) or as modifiers.
  * conciseness is valued, but avoid abbreviation ([`indexin`](@ref) rather than `indxin`) as
    it becomes difficult to remember whether and how particular words are abbreviated. --><p>如果一个函数名需要多个单词，请考虑这个函数是否代表了超过一个概念，是不是分成几个更小的部分更好。</p><!-- If a function name requires multiple words, consider whether it might represent more than one
concept and might be better split into pieces. --><h2><a class="nav-anchor" id="使用与-Julia-的-Base-模块类似的参数顺序-1" href="#使用与-Julia-的-Base-模块类似的参数顺序-1">使用与 Julia 的 Base 模块类似的参数顺序</a></h2><!-- ## Write functions with argument ordering similar to Julia's Base --><p>一般来说，Base 库使用以下的函数参数顺序（如适用）：</p><!-- As a general rule, the Base library uses the following order of arguments to functions,
as applicable: --><ol><li><strong>Function 参数</strong>。把作为参数的函数放在第一位可以方便使用 <a href="../../base/base/#do"><code>do</code></a>，以传递多行匿名函数。</li></ol><!-- 1. **Function argument**.
   Putting a function argument first permits the use of [`do`](@ref) blocks for passing
   multiline anonymous functions. --><ol><li><strong>I/O 流</strong>。把 <code>IO</code> 对象放在第一位，可以方便将函数传递给 <a href="../../base/io-network/#Base.sprint"><code>sprint</code></a> 之类的函数，例如 <code>sprint(show, x)</code>。</li></ol><!-- 2. **I/O stream**.
   Specifying the `IO` object first permits passing the function to functions such as
   [`sprint`](@ref), e.g. `sprint(show, x)`. --><ol><li><strong>要被修改的输入</strong>。比如，在 <a href="../../base/arrays/#Base.fill!"><code>fill!(x, v)</code></a> 中，<code>x</code> 是要被修改的对象，所以放在要被插入 <code>x</code> 中的值前面。</li></ol><!-- 3. **Input being mutated**.
   For example, in [`fill!(x, v)`](@ref fill!), `x` is the object being mutated and it
   appears before the value to be inserted into `x`. --><ol><li><strong>类型</strong>。把类型传入通常意味着要输出的值有着那种类型。在 <a href="../../base/numbers/#Base.parse"><code>parse(Int, &quot;1&quot;)</code></a> 中，类型在需要解析的字符串之前。还有很多类似的把类型放在第一位的例子，但是同时也需要注意到例如 <a href="../../base/io-network/#Base.read"><code>read(io, String)</code></a> 这样的函数中，会把 <code>IO</code> 参数放在类型的更前面，这样还是保持着这里描述的顺序。</li></ol><!-- 4. **Type**.
   Passing a type typically means that the output will have the given type.
   In [`parse(Int, "1")`](@ref parse), the type comes before the string to parse.
   There are many such examples where the type appears first, but it's useful to note that
   in [`read(io, String)`](@ref read), the `IO` argument appears before the type, which is
   in keeping with the order outlined here. --><ol><li><strong>不被修改的输入</strong>。比如在 <code>fill!(x, v)</code> 中的<strong>不</strong>被修改的 <code>v</code>，会放在 <code>x</code> 之后传入。</li></ol><!-- 5. **Input not being mutated**.
   In `fill!(x, v)`, `v` is *not* being mutated and it comes after `x`. --><ol><li><strong>键（Key）</strong>。对于关联集合来说，指的是键值对的键。对于其它有索引的集合来说，指的是索引。</li></ol><!-- 6. **Key**.
   For associative collections, this is the key of the key-value pair(s).
   For other indexed collections, this is the index. --><ol><li><strong>值（Value）</strong>。对于关联集合来说，指的是键值对的值。在类似于 <code>fill!(x, v)</code> 的情况中，指的是 <code>v</code>。</li></ol><!-- 7. **Value**.
   For associative collections, this is the value of the key-value pair(s).
   In cases like `fill!(x, v)`, this is `v`. --><ol><li><strong>其它的所有</strong>。任何的其它参数。</li></ol><!-- 8. **Everything else**.
   Any other arguments. --><ol><li><strong>可变参数（Vararg）</strong>。指的是在函数调用时可以被无限列在后面的参数。比如在 <code>Matrix{T}(uninitialized, dims)</code> 中，维数（dims）可以作为 <a href="../../base/base/#Core.Tuple"><code>Tuple</code></a> 被传入（如 <code>Matrix{T}(uninitialized, (1,2))</code>），也可以作为可变参数（<a href="../../base/base/#Core.Vararg"><code>Vararg</code></a>，如 <code>Matrix{T}(uninitialized, 1, 2)</code>。</li></ol><!-- 9. **Varargs**.
   This refers to arguments that can be listed indefinitely at the end of a function call.
   For example, in `Matrix{T}(uninitialized, dims)`, the dimensions can be given as a
   [`Tuple`](@ref), e.g. `Matrix{T}(uninitialized, (1,2))`, or as [`Vararg`](@ref)s,
   e.g. `Matrix{T}(uninitialized, 1, 2)`. --><ol><li><strong>关键字参数</strong>。在 Julia 中，关键字参数本来就不得不定义在函数定义的最后，列在这里仅仅是为了完整性。</li></ol><!-- 10. **Keyword arguments**.
   In Julia keyword arguments have to come last anyway in function definitions; they're
   listed here for the sake of completeness. --><p>大多数函数并不会接受上述所有种类的参数，这些数字仅仅是表示当适用时的优先权。</p><!-- The vast majority of functions will not take every kind of argument listed above; the
numbers merely denote the precedence that should be used for any applicable arguments
to a function. --><p>当然，在一些情况下有例外。例如，<a href="../../base/base/#Base.convert"><code>convert</code></a> 函数总是把类型作为第一个参数。<a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a> 函数的值参数在索引参数之前，这样可以让索引作为可变参数传入。</p><!-- There are of course a few exceptions.
For example, in [`convert`](@ref), the type should always come first.
In [`setindex!`](@ref), the value comes before the indices so that the indices can be
provided as varargs. --><p>设计 API 时，尽可能秉承着这种一般顺序会让函数的使用者有一种更一致的体验。</p><!-- When designing APIs, adhering to this general order as much as possible is likely to give
users of your functions a more consistent experience. --><h2><a class="nav-anchor" id="不要过度使用-try-catch-1" href="#不要过度使用-try-catch-1">不要过度使用 try-catch</a></h2><!-- ## Don't overuse try-catch --><p>比起依赖于捕获错误，更好的是避免错误。</p><!-- It is better to avoid errors than to rely on catching them. --><h2><a class="nav-anchor" id="不要给条件语句加括号-1" href="#不要给条件语句加括号-1">不要给条件语句加括号</a></h2><!-- ## Don't parenthesize conditions --><p>Julia 不要求在 <code>if</code> 和 <code>while</code> 后的条件两边加括号。使用如下写法：</p><!-- Julia doesn't require parens around conditions in `if` and `while`. Write: --><pre><code class="language-julia">if a == b</code></pre><p>而不是:</p><pre><code class="language-julia">if (a == b)</code></pre><h2><a class="nav-anchor" id="不要过度使用-...-1" href="#不要过度使用-...-1">不要过度使用 <code>...</code></a></h2><!-- ## Don't overuse `...` --><p>拼接函数参数是会上瘾的。请用简单的 <code>[a; b]</code> 来代替 <code>[a..., b...]</code>，因为前者已经是被拼接的数组了。<a href="../../base/collections/#Base.collect-Tuple{Any}"><code>collect(a)</code></a> 也比 <code>[a...]</code> 更好，但因为 <code>a</code> 已经是一个可迭代的变量了，通常不把它转换成数组就直接使用甚至更好。</p><!-- Splicing function arguments can be addictive. Instead of `[a..., b...]`, use simply `[a; b]`,
which already concatenates arrays. [`collect(a)`](@ref) is better than `[a...]`, but since `a`
is already iterable it is often even better to leave it alone, and not convert it to an array. --><h2><a class="nav-anchor" id="不要使用不必要的静态参数-1" href="#不要使用不必要的静态参数-1">不要使用不必要的静态参数</a></h2><!-- ## Don't use unnecessary static parameters --><p>如下的函数签名：</p><!-- A function signature: --><pre><code class="language-julia">foo(x::T) where {T&lt;:Real} = ...</code></pre><p>应当被写作：</p><!-- should be written as: --><pre><code class="language-julia">foo(x::Real) = ...</code></pre><p>尤其是当 <code>T</code> 没有被用在函数体中时格外有意义。即使 <code>T</code> 被用到了，通常也可以被替换为 <a href="../../base/base/#Core.typeof"><code>typeof(x)</code></a>，后者不会导致性能上的差别。注意这并不是针对静态参数的一般警告，而仅仅是针对那些不必要的情况。</p><!-- instead, especially if `T` is not used in the function body. Even if `T` is used, it can be replaced
with [`typeof(x)`](@ref) if convenient. There is no performance difference. Note that this is
not a general caution against static parameters, just against uses where they are not needed. --><p>同样需要注意的是，容器类型在函数调用中可能明确地需要类型参数。详情参见<a href="manual/@ref">避免使用抽象容器的域</a>。</p><!-- Note also that container types, specifically may need type parameters in function calls. See the
FAQ [Avoid fields with abstract containers](@ref) for more information. --><h2><a class="nav-anchor" id="避免判断变量是实例还是类型的混乱-1" href="#避免判断变量是实例还是类型的混乱-1">避免判断变量是实例还是类型的混乱</a></h2><!-- ## Avoid confusion about whether something is an instance or a type --><p>如下的一组定义容易令人困惑：</p><!-- Sets of definitions like the following are confusing: --><pre><code class="language-julia">foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)</code></pre><p>请决定问题里的概念应当是 <code>MyType</code> 还是 <code>MyType()</code>，然后坚持使用其一。</p><!-- Decide whether the concept in question will be written as `MyType` or `MyType()`, and stick to
it. --><p>默认使用实例是比较受推崇的风格，然后只在为了解决一些问题必要时添加涉及到 <code>Type{MyType}</code> 的方法。</p><!-- The preferred style is to use instances by default, and only add methods involving `Type{MyType}`
later if they become necessary to solve some problem. --><p>如果一个类型实际上是个枚举，它应该被定义成一个单一的类型（理想的情况是不可变结构或原始类型），把枚举值作为它的实例。构造器和转换器可以检查那些值是否有效。这种设计比把枚举做成抽象类型，并把“值”做成子类型来得更受推崇。</p><!-- If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive)
type, with the enumeration values being instances of it. Constructors and conversions can check
whether values are valid. This design is preferred over making the enumeration an abstract type,
with the "values" as subtypes. --><h2><a class="nav-anchor" id="不要过度使用宏-1" href="#不要过度使用宏-1">不要过度使用宏</a></h2><!-- ## Don't overuse macros --><p>请注意有的宏实际上可以被写成一个函数。</p><!-- Be aware of when a macro could really be a function instead. --><p>在宏内部调用 <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> 是一个特别危险的警告标志，它意味着这个宏仅在被最外层调用时起作用。如果这样的宏被写成函数，它会自然地访问得到它所需要的运行时值。</p><!-- Calling [`eval`](@ref) inside a macro is a particularly dangerous warning sign; it means the
macro will only work when called at the top level. If such a macro is written as a function instead,
it will naturally have access to the run-time values it needs. --><h2><a class="nav-anchor" id="不要把不安全的操作暴露在接口层-1" href="#不要把不安全的操作暴露在接口层-1">不要把不安全的操作暴露在接口层</a></h2><!-- ## Don't expose unsafe operations at the interface level --><p>如果你有一个使用本地指针的类型：</p><!-- If you have a type that uses a native pointer: --><pre><code class="language-julia">mutable struct NativeType
    p::Ptr{UInt8}
    ...
end</code></pre><p>不要定义类似如下的函数：</p><!-- don't write definitions like the following: --><pre><code class="language-julia">getindex(x::NativeType, i) = unsafe_load(x.p, i)</code></pre><p>这里的问题在于，这个类型的用户可能会在意识不到这个操作不安全的情况下写出 <code>x[i]</code>，然后容易遇到内存错误。</p><!-- The problem is that users of this type can write `x[i]` without realizing that the operation is
unsafe, and then be susceptible to memory bugs. --><p>在这样的函数中，可以加上对操作的检查来确保安全，或者可以在名字的某处加上 <code>unsafe</code> 来警告调用者。</p><!-- Such a function should either check the operation to ensure it is safe, or have `unsafe` somewhere
in its name to alert callers. --><h2><a class="nav-anchor" id="不要重载基础容器类型的方法-1" href="#不要重载基础容器类型的方法-1">不要重载基础容器类型的方法</a></h2><!-- ## Don't overload methods of base container types --><p>有时可能会想要写这样的定义：</p><!-- It is possible to write definitions like the following: --><pre><code class="language-julia">show(io::IO, v::Vector{MyType}) = ...</code></pre><p>这样可以提供对特定的某种新元素类型的向量的自定义显示。这种做法虽然很诱人，但应当被避免。这里的问题在于用户会想着一个像 <code>Vector()</code> 这样熟知的类型以某种方式表现，但过度自定义的行为会让使用变得更难。</p><!-- This would provide custom showing of vectors with a specific new element type. While tempting,
this should be avoided. The trouble is that users will expect a well-known type like `Vector()`
to behave in a certain way, and overly customizing its behavior can make it harder to work with. --><h2><a class="nav-anchor" id="避免类型盗版-1" href="#避免类型盗版-1">避免类型盗版</a></h2><!-- ## Avoid type piracy --><p>“类型盗版”（type piracy）指的是扩展或是重定义 Base 或其它包中的并不是你所定义的类型的方法。在某些情况下，你可以几乎毫无副作用地逃避类型盗版。但在极端情况下，你甚至会让 Julia 崩溃（比如说你的方法扩展或重定义造成了对 <code>ccall</code> 传入了无效的输入）。类型盗版也让代码推导变得更复杂，且可能会引入难以预料和诊断的不兼容性。</p><!-- "Type piracy" refers to the practice of extending or redefining methods in Base
or other packages on types that you have not defined. In some cases, you can get away with
type piracy with little ill effect. In extreme cases, however, you can even crash Julia
(e.g. if your method extension or redefinition causes invalid input to be passed to a
`ccall`). Type piracy can complicate reasoning about code, and may introduce
incompatibilities that are hard to predict and diagnose. --><p>例如，你也许想在一个模块中定义符号上的乘法：</p><!-- As an example, suppose you wanted to define multiplication on symbols in a module: --><pre><code class="language-julia">module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end</code></pre><p>这里的问题时现在其它用到 <code>Base.*</code> 的模块同样会看到这个定义。由于 <code>Symbol</code> 是定义在 Base 里再被其它模块所使用的，这可能不可预料地改变无关代码的行为。这里有几种替代的方式，包括使用一个不同的函数名称，或是把 <code>Symbol</code> 给包在另一个你自己定义的类型中。</p><!-- The problem is that now any other module that uses `Base.*` will also see this definition.
Since `Symbol` is defined in Base and is used by other modules, this can change the
behavior of unrelated code unexpectedly. There are several alternatives here, including
using a different function name, or wrapping the `Symbol`s in another type that you define. --><p>有时候，耦合的包可能会使用类型盗版，以此来从定义分隔特性，尤其是当那些包是一些合作的作者设计的时候，且那些定义是可重用的时候。例如，一个包可能提供一些对处理色彩有用的类型，另一个包可能为那些类型定义色彩空间之间转换的方法。再举一个例子，一个包可能是一些 C 代码的简易包装，另一个包可能就“盗版”来实现一些更高级别的、对 Julia 友好的 API。</p><!-- Sometimes, coupled packages may engage in type piracy to separate features from definitions,
especially when the packages were designed by collaborating authors, and when the
definitions are reusable. For example, one package might provide some types useful for
working with colors; another package could define methods for those types that enable
conversions between color spaces. Another example might be a package that acts as a thin
wrapper for some C code, which another package might then pirate to implement a
higher-level, Julia-friendly API. --><h2><a class="nav-anchor" id="注意类型相等-1" href="#注意类型相等-1">注意类型相等</a></h2><!-- ## Be careful with type equality --><p>通常会用 <a href="../../base/base/#Core.isa"><code>isa</code></a> 和 <a href="../../base/base/#Core.:&lt;:"><code>&lt;:</code></a> 来对类型进行测试，而不会用到 <code>==</code>。检测类型的相等通常只对和一个已知的具体类型比较有意义（例如 <code>T == Float64</code>），或者你<strong>真的真的</strong>知道自己在做什么。</p><!-- You generally want to use [`isa`](@ref) and [`<:`](@ref) for testing types,
not `==`. Checking types for exact equality typically only makes sense when comparing to a known
concrete type (e.g. `T == Float64`), or if you *really, really* know what you're doing. --><h2><a class="nav-anchor" id="不要写-x-f(x)-1" href="#不要写-x-f(x)-1">不要写 <code>x-&gt;f(x)</code></a></h2><!-- ## Do not write `x->f(x)` --><p>因为调用高阶函数时经常会用到匿名函数，很容易认为这是合理甚至必要的。但任何函数都可以被直接传递，并不需要被“包&quot;在一个匿名函数中。比如 <code>map(x-&gt;f(x), a)</code> 应当被写成 <a href="../../base/collections/#Base.map"><code>map(f, a)</code></a>。</p><!-- Since higher-order functions are often called with anonymous functions, it is easy to conclude
that this is desirable or even necessary. But any function can be passed directly, without being
"wrapped" in an anonymous function. Instead of writing `map(x->f(x), a)`, write [`map(f, a)`](@ref). --><h2><a class="nav-anchor" id="尽可能避免使用浮点数作为通用代码的字面量-1" href="#尽可能避免使用浮点数作为通用代码的字面量-1">尽可能避免使用浮点数作为通用代码的字面量</a></h2><!-- ## Avoid using floats for numeric literals in generic code when possible --><p>当写处理数字，且可以处理多种不同数字类型的参数的通用代码时，请使用对参数影响（通过类型提升）尽可能少的类型的字面量。</p><!-- If you write generic code which handles numbers, and which can be expected to run with many different
numeric type arguments, try using literals of a numeric type that will affect the arguments as
little as possible through promotion. --><p>例如，</p><!-- For example, --><pre><code class="language-julia-repl">julia&gt; f(x) = 2.0 * x
f (generic function with 1 method)

julia&gt; f(1//2)
1.0

julia&gt; f(1/2)
1.0

julia&gt; f(1)
2.0</code></pre><p>而</p><!-- while --><pre><code class="language-julia-repl">julia&gt; g(x) = 2 * x
g (generic function with 1 method)

julia&gt; g(1//2)
1//1

julia&gt; g(1/2)
1.0

julia&gt; g(1)
2</code></pre><p>如你所见，使用了 <code>Int</code> 字面量的第二个版本保留了输入参数的类型，而第一个版本没有。这是因为例如 <code>promote_type(Int, Float64) == Float64</code>，且做乘法时会需要类型提升。类似地，<a href="../../base/numbers/#Base.Rational"><code>Rational</code></a> 字面量比 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 字面量对类型有着更小的破坏性，但比 <code>Int</code> 大。</p><!-- As you can see, the second version, where we used an `Int` literal, preserved the type of the
input argument, while the first didn't. This is because e.g. `promote_type(Int, Float64) == Float64`,
and promotion happens with the multiplication. Similarly, [`Rational`](@ref) literals are less type disruptive
than [`Float64`](@ref) literals, but more disruptive than `Int`s: --><pre><code class="language-julia-repl">julia&gt; h(x) = 2//1 * x
h (generic function with 1 method)

julia&gt; h(1//2)
1//1

julia&gt; h(1/2)
1.0

julia&gt; h(1)
2//1</code></pre><p>所以，可能时尽量使用 <code>Int</code> 字面量，对非整数字面量使用 <code>Rational{Int}</code>，这样可以让代码变得更容易使用。</p><!-- Thus, use `Int` literals when possible, with `Rational{Int}` for literal non-integer numbers,
in order to make it easier to use your code. --><footer><hr/><a class="previous" href="../parallel-computing/"><span class="direction">Previous</span><span class="title">并行计算</span></a><a class="next" href="../../base/base/"><span class="direction">Next</span><span class="title">重要组件</span></a></footer></article></body></html>
