<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>复数与分数 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="http://docs.juliacn.com/latest/manual/complex-and-rational-numbers/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">起步</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li class="current"><a class="toctext" href>复数与分数</a><ul class="internal"><li><a class="toctext" href="#复数-1">复数</a></li><li><a class="toctext" href="#分数-1">分数</a></li></ul></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li></ul></li><li><span class="toctext">基础组件</span><ul><li><a class="toctext" href="../../base/base/">重要组件</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">数组</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O 和网络（Network）</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">中文文档开发</span><ul><li><a class="toctext" href="../../juliacn/style-guide/">翻译格式指引</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>复数与分数</a></li></ul><a class="edit-page" href="https://github.com/findmyway/JuliaZH.jl/blob/master/docs/src/manual/complex-and-rational-numbers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>复数与分数</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="复数与分数-1" href="#复数与分数-1">复数与分数</a></h1><!-- # Complex and Rational Numbers --><p>Julia 语言自带预定义的表示复数与分数的类型，并且支持它们的各种<a href="manual/@ref">标准数学操作与基础函数</a>。由于也定义了复数与分数的<a href="manual/@ref conversion-and-promotion">转换与提升</a>，因此对预定义数值类型（无论是原始的还是复合的）的任意组合进行的操作都会表现得如预期的一样。</p><!-- Julia ships with predefined types representing both complex and rational numbers, and supports
all standard [Mathematical Operations and Elementary Functions](@ref) on them. [Conversion and Promotion](@ref conversion-and-promotion) are defined
so that operations on any combination of predefined numeric types, whether primitive or composite,
behave as expected. --><h2><a class="nav-anchor" id="复数-1" href="#复数-1">复数</a></h2><!-- ## Complex Numbers --><p>在Julia中,全局常量 <a href="../../base/numbers/#Base.im"><code>im</code></a> 被绑定到复数 <em>i</em>，表示 -1 的主平方根。由于 <code>i</code> 是一个很流行的用作索引的变量名，所以直接把它作为全局常量被认为是很危险的。由于 Julia 允许数值文本<a href="../integers-and-floating-point-numbers/#man-numeric-literal-coefficients-1">作为系数与标识符并置</a>，这种绑定就足够为复数提供很方便的语法，类似于传统的数学记法：</p><!-- The global constant [`im`](@ref) is bound to the complex number *i*, representing the principal
square root of -1. It was deemed harmful to co-opt the name `i` for a global constant, since it
is such a popular index variable name. Since Julia allows numeric literals to be [juxtaposed with identifiers as coefficients](@ref man-numeric-literal-coefficients),
this binding suffices to provide convenient syntax for complex numbers, similar to the traditional
mathematical notation: --><pre><code class="language-julia-repl">julia&gt; 1 + 2im
1 + 2im</code></pre><p>你可以对复数进行各种标准算术操作：</p><!-- You can perform all the standard arithmetic operations with complex numbers: --><pre><code class="language-julia-repl">julia&gt; (1 + 2im)*(2 - 3im)
8 + 1im

julia&gt; (1 + 2im)/(1 - 2im)
-0.6 + 0.8im

julia&gt; (1 + 2im) + (1 - 2im)
2 + 0im

julia&gt; (-3 + 2im) - (5 - 1im)
-8 + 3im

julia&gt; (-1 + 2im)^2
-3 - 4im

julia&gt; (-1 + 2im)^2.5
2.7296244647840084 - 6.960664459571898im

julia&gt; (-1 + 2im)^(1 + 1im)
-0.27910381075826657 + 0.08708053414102428im

julia&gt; 3(2 - 5im)
6 - 15im

julia&gt; 3(2 - 5im)^2
-63 - 60im

julia&gt; 3(2 - 5im)^-1.0
0.20689655172413796 + 0.5172413793103449im</code></pre><p>类型提升机制也确保你可以使用不同类型的操作数的组合：</p><!-- The promotion mechanism ensures that combinations of operands of different types just work: --><pre><code class="language-julia-repl">julia&gt; 2(1 - 1im)
2 - 2im

julia&gt; (2 + 3im) - 1
1 + 3im

julia&gt; (1 + 2im) + 0.5
1.5 + 2.0im

julia&gt; (2 + 3im) - 0.5im
2.0 + 2.5im

julia&gt; 0.75(1 + 2im)
0.75 + 1.5im

julia&gt; (2 + 3im) / 2
1.0 + 1.5im

julia&gt; (1 - 3im) / (2 + 2im)
-0.5 - 1.0im

julia&gt; 2im^2
-2 + 0im

julia&gt; 1 + 3/4im
1.0 - 0.75im</code></pre><p>注意 <code>3/4im == 3/(4*im) == -(3/4*im)</code>，因为文本系数比除法的优先级更高。</p><!-- Note that `3/4im == 3/(4*im) == -(3/4*im)`, since a literal coefficient binds more tightly than
division. --><p>Julia 提供了一些用来操作复数值的标准函数：</p><!-- Standard functions to manipulate complex values are provided: --><pre><code class="language-julia-repl">julia&gt; z = 1 + 2im
1 + 2im

julia&gt; real(1 + 2im) # real part of z
1

julia&gt; imag(1 + 2im) # imaginary part of z
2

julia&gt; conj(1 + 2im) # complex conjugate of z
1 - 2im

julia&gt; abs(1 + 2im) # absolute value of z
2.23606797749979

julia&gt; abs2(1 + 2im) # squared absolute value
5

julia&gt; angle(1 + 2im) # phase angle in radians
1.1071487177940904</code></pre><p>按照惯例，复数的绝对值（<a href="../../base/math/#Base.abs"><code>abs</code></a>）是从零点到它的距离。<a href="../../base/math/#Base.abs2"><code>abs2</code></a> 给出绝对值的平方，作用于复数上时非常有用,可以避免做平方根的操作。[<code>angle</code>] 返回以弧度为单位的相位角（这也被称为辐角函数）。所有其它的<a href="manual/@ref">基础函数</a>在复数上也都有完整的定义：</p><!-- As usual, the absolute value ([`abs`](@ref)) of a complex number is its distance from zero.
[`abs2`](@ref) gives the square of the absolute value, and is of particular use for complex
numbers where it avoids taking a square root. [`angle`](@ref) returns the phase angle in radians
(also known as the *argument* or *arg* function). The full gamut of other [Elementary Functions](@ref)
is also defined for complex numbers: --><pre><code class="language-julia-repl">julia&gt; sqrt(1im)
0.7071067811865476 + 0.7071067811865475im

julia&gt; sqrt(1 + 2im)
1.272019649514069 + 0.7861513777574233im

julia&gt; cos(1 + 2im)
2.0327230070196656 - 3.0518977991518im

julia&gt; exp(1 + 2im)
-1.1312043837568135 + 2.4717266720048188im

julia&gt; sinh(1 + 2im)
-0.4890562590412937 + 1.4031192506220405im</code></pre><p>注意数学函数通常应用于实数就返回实数值，应用于复数就返回复数值。例如，当 <a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a> 应用于 <code>-1</code> 与 <code>-1 + 0im</code> 会有不同的表现，虽然 <code>-1 == -1 + 0im</code>：</p><!-- Note that mathematical functions typically return real values when applied to real numbers and
complex values when applied to complex numbers. For example, [`sqrt`](@ref) behaves differently
when applied to `-1` versus `-1 + 0im` even though `-1 == -1 + 0im`: --><pre><code class="language-julia-repl">julia&gt; sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]

julia&gt; sqrt(-1 + 0im)
0.0 + 1.0im</code></pre><p>从变量构建复数时，<a href="../integers-and-floating-point-numbers/#man-numeric-literal-coefficients-1">文本型数值系数记法</a>不再适用。相反地，乘法必须显式地写出：</p><!-- The [literal numeric coefficient notation](@ref man-numeric-literal-coefficients) does not work when constructing a complex number
from variables. Instead, the multiplication must be explicitly written out: --><pre><code class="language-julia-repl">julia&gt; a = 1; b = 2; a + b*im
1 + 2im</code></pre><p>然而，我们<strong>并不</strong>推荐这样，而应改为使用 <a href="../../base/numbers/#Base.complex-Tuple{Complex}"><code>complex</code></a> 函数直接通过实部与虚部构建一个复数值：</p><!-- However, this is *not* recommended; Use the [`complex`](@ref) function instead to construct
a complex value directly from its real and imaginary parts: --><pre><code class="language-julia-repl">julia&gt; a = 1; b = 2; complex(a, b)
1 + 2im</code></pre><p>这种构建避免了乘法和加法操作。</p><!-- This construction avoids the multiplication and addition operations. --><p><a href="../../base/numbers/#Base.Inf"><code>Inf</code></a> 和 <a href="../../base/numbers/#Base.NaN"><code>NaN</code></a> 可能出现在复数的实部和虚部，正如<a href="../integers-and-floating-point-numbers/#特殊的浮点值-1">特殊的浮点值</a>章节所描述的：</p><!-- [`Inf`](@ref) and [`NaN`](@ref) propagate through complex numbers in the real and imaginary parts
of a complex number as described in the [Special floating-point values](@ref) section: --><pre><code class="language-julia-repl">julia&gt; 1 + Inf*im
1.0 + Inf*im

julia&gt; 1 + NaN*im
1.0 + NaN*im</code></pre><h2><a class="nav-anchor" id="分数-1" href="#分数-1">分数</a></h2><!-- ## Rational Numbers --><p>Julia 有一个用于表示整数精确比值的分数类型。分数通过 <a href="../../base/math/#Base.://"><code>//</code></a> 运算符构建：</p><!-- Julia has a rational number type to represent exact ratios of integers. Rationals are constructed
using the [`//`](@ref) operator: --><pre><code class="language-julia-repl">julia&gt; 2//3
2//3</code></pre><p>如果一个分数的分子和分母含有公因子，它们会被约分到最简形式且分母非负：</p><!-- If the numerator and denominator of a rational have common factors, they are reduced to lowest
terms such that the denominator is non-negative: --><pre><code class="language-julia-repl">julia&gt; 6//9
2//3

julia&gt; -4//8
-1//2

julia&gt; 5//-15
-1//3

julia&gt; -4//-12
1//3</code></pre><p>整数比值的这种标准化形式是唯一的，所以分数值的相等性可由校验分子与分母都相等来测试。分数值的标准化分子和分母可以使用 <a href="../../base/math/#Base.numerator"><code>numerator</code></a> 和 <a href="../../base/math/#Base.denominator"><code>denominator</code></a> 函数得到：</p><!-- This normalized form for a ratio of integers is unique, so equality of rational values can be
tested by checking for equality of the numerator and denominator. The standardized numerator and
denominator of a rational value can be extracted using the [`numerator`](@ref) and [`denominator`](@ref)
functions: --><pre><code class="language-julia-repl">julia&gt; numerator(2//3)
2

julia&gt; denominator(2//3)
3</code></pre><p>分子和分母的直接比较通常是不必要的，因为标准算术和比较操作对分数值也有定义：</p><!-- Direct comparison of the numerator and denominator is generally not necessary, since the standard
arithmetic and comparison operations are defined for rational values: --><pre><code class="language-julia-repl">julia&gt; 2//3 == 6//9
true

julia&gt; 2//3 == 9//27
false

julia&gt; 3//7 &lt; 1//2
true

julia&gt; 3//4 &gt; 2//3
true

julia&gt; 2//4 + 1//6
2//3

julia&gt; 5//12 - 1//4
1//6

julia&gt; 5//8 * 3//12
5//32

julia&gt; 6//5 / 10//7
21//25</code></pre><p>分数可以很容易地被转换成浮点数：</p><!-- Rationals can be easily converted to floating-point numbers: --><pre><code class="language-julia-repl">julia&gt; float(3//4)
0.75</code></pre><p>对任意整数值 <code>a</code> 和 <code>b</code>（除了 <code>a == 0</code> 且 <code>b == 0</code> 时），从分数到浮点数的转换遵从以下的一致性：</p><!-- Conversion from rational to floating-point respects the following identity for any integral values
of `a` and `b`, with the exception of the case `a == 0` and `b == 0`: --><pre><code class="language-julia-repl">julia&gt; a = 1; b = 2;

julia&gt; isequal(float(a//b), a/b)
true</code></pre><p>Julia接受构建无穷分数值：</p><!-- Constructing infinite rational values is acceptable: --><pre><code class="language-julia-repl">julia&gt; 5//0
1//0

julia&gt; -3//0
-1//0

julia&gt; typeof(ans)
Rational{Int64}</code></pre><p>但不接受试图构建一个 <a href="../../base/numbers/#Base.NaN"><code>NaN</code></a> 分数值：</p><!-- Trying to construct a [`NaN`](@ref) rational value, however, is not: --><pre><code class="language-julia-repl">julia&gt; 0//0
ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)
Stacktrace:
[...]</code></pre><p>像往常一样，类型提升系统使得分数可以轻松地同其它数值类型进行交互：</p><!-- As usual, the promotion system makes interactions with other numeric types effortless: --><pre><code class="language-julia-repl">julia&gt; 3//5 + 1
8//5

julia&gt; 3//5 - 0.5
0.09999999999999998

julia&gt; 2//7 * (1 + 2im)
2//7 + 4//7*im

julia&gt; 2//7 * (1.5 + 2im)
0.42857142857142855 + 0.5714285714285714im

julia&gt; 3//2 / (1 + 2im)
3//10 - 3//5*im

julia&gt; 1//2 + 2im
1//2 + 2//1*im

julia&gt; 1 + 2//3im
1//1 - 2//3*im

julia&gt; 0.5 == 1//2
true

julia&gt; 0.33 == 1//3
false

julia&gt; 0.33 &lt; 1//3
true

julia&gt; 1//3 - 0.33
0.0033333333333332993</code></pre><footer><hr/><a class="previous" href="../integers-and-floating-point-numbers/"><span class="direction">Previous</span><span class="title">整数和浮点数</span></a><a class="next" href="../strings/"><span class="direction">Next</span><span class="title">字符串</span></a></footer></article></body></html>
