<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>数组 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="http://docs.juliacn.com/latest/base/arrays/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../../manual/getting-started/">起步</a></li><li><a class="toctext" href="../../manual/variables/">变量</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">复数与分数</a></li><li><a class="toctext" href="../../manual/strings/">字符串</a></li><li><a class="toctext" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="toctext" href="../../manual/style-guide/">代码风格指南</a></li></ul></li><li><span class="toctext">基础组件</span><ul><li><a class="toctext" href="../base/">重要组件</a></li><li><a class="toctext" href="../collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../math/">Mathematics</a></li><li><a class="toctext" href="../numbers/">Numbers</a></li><li><a class="toctext" href="../strings/">Strings</a></li><li class="current"><a class="toctext" href>数组</a><ul class="internal"><li><a class="toctext" href="#构造器和类型-1">构造器和类型</a></li><li><a class="toctext" href="#基本函数-1">基本函数</a></li><li><a class="toctext" href="#广播和向量化-1">广播和向量化</a></li><li><a class="toctext" href="#索引和赋值-1">索引和赋值</a></li><li><a class="toctext" href="#查看（Views，SubArrays和其它查看类型）-1">查看（Views，SubArrays和其它查看类型）</a></li><li><a class="toctext" href="#连接和置换-1">连接和置换</a></li><li><a class="toctext" href="#数组函数-1">数组函数</a></li><li><a class="toctext" href="#组合-1">组合</a></li></ul></li><li><a class="toctext" href="../parallel/">Tasks</a></li><li><a class="toctext" href="../multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../constants/">Constants</a></li><li><a class="toctext" href="../file/">Filesystem</a></li><li><a class="toctext" href="../io-network/">I/O 和网络（Network）</a></li><li><a class="toctext" href="../punctuation/">Punctuation</a></li><li><a class="toctext" href="../sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../iterators/">Iteration utilities</a></li><li><a class="toctext" href="../c/">C Interface</a></li><li><a class="toctext" href="../libc/">C Standard Library</a></li><li><a class="toctext" href="../stacktraces/">StackTraces</a></li><li><a class="toctext" href="../simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">中文文档开发</span><ul><li><a class="toctext" href="../../juliacn/style-guide/">翻译格式指引</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>基础组件</li><li><a href>数组</a></li></ul><a class="edit-page" href="https://github.com/findmyway/JuliaZH.jl/blob/master/docs/src/base/arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>数组</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="lib-arrays-1" href="#lib-arrays-1">数组</a></h1><h2><a class="nav-anchor" id="构造器和类型-1" href="#构造器和类型-1">构造器和类型</a></h2><!-- ## Constructors and Types --><pre><code class="language-none">Core.AbstractArray
Base.AbstractVector
Base.AbstractMatrix
Base.AbstractVecOrMat
Core.Array
Core.Array(::UndefInitializer, ::Any)
Core.Array(::Nothing, ::Any)
Core.Array(::Missing, ::Any)
Core.UndefInitializer
Core.undef
Base.Vector
Base.Vector(::UndefInitializer, ::Any)
Base.Vector(::Nothing, ::Any)
Base.Vector(::Missing, ::Any)
Base.Matrix
Base.Matrix(::UndefInitializer, ::Any, ::Any)
Base.Matrix(::Nothing, ::Any, ::Any)
Base.Matrix(::Missing, ::Any, ::Any)
Base.VecOrMat
Core.DenseArray
Base.DenseVector
Base.DenseMatrix
Base.DenseVecOrMat
Base.getindex(::Type, ::Any...)
Base.zeros
Base.ones
Base.BitArray
Base.BitArray(::UndefInitializer, ::Integer...)
Base.BitArray(::Any)
Base.trues
Base.falses
Base.fill
Base.fill!
Base.similar</code></pre><h2><a class="nav-anchor" id="基本函数-1" href="#基本函数-1">基本函数</a></h2><!-- ## Basic functions --><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ndims" href="#Base.ndims"><code>Base.ndims</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ndims(A::AbstractArray) -&gt; Integer</code></pre><p>Return the number of dimensions of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = fill(1, (3,4,5));

julia&gt; ndims(A)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L116-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">size(A::AbstractArray, [dim])</code></pre><p>Return a tuple containing the dimensions of <code>A</code>. Optionally you can specify a dimension to just get the length of that dimension.</p><p>Note that <code>size</code> may not be defined for arrays with non-standard indices, in which case <a href="#Base.axes-Tuple{Any}"><code>axes</code></a> may be useful. See the manual chapter on <a href="base/@ref man-custom-indices">arrays with custom indices</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = fill(1, (2,3,4));

julia&gt; size(A)
(2, 3, 4)

julia&gt; size(A, 2)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L26-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.axes-Tuple{Any}" href="#Base.axes-Tuple{Any}"><code>Base.axes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">axes(A)</code></pre><p>Return the tuple of valid indices for array <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = fill(1, (5,6,7));

julia&gt; axes(A)
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L68-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.axes-Tuple{AbstractArray,Any}" href="#Base.axes-Tuple{AbstractArray,Any}"><code>Base.axes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">axes(A, d)</code></pre><p>Return the valid range of indices for array <code>A</code> along dimension <code>d</code>.</p><p>See also <a href="#Base.size"><code>size</code></a>, and the manual chapter on <a href="base/@ref man-custom-indices">arrays with custom indices</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = fill(1, (5,6,7));

julia&gt; axes(A, 2)
Base.OneTo(6)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L48-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{AbstractArray}" href="#Base.length-Tuple{AbstractArray}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">length(A::AbstractArray)</code></pre><p>Return the number of elements in the array, defaults to <code>prod(size(A))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; length([1, 2, 3, 4])
4

julia&gt; length([1 2; 3 4])
4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L153-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eachindex" href="#Base.eachindex"><code>Base.eachindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eachindex(A...)</code></pre><p>Create an iterable object for visiting each index of an <code>AbstractArray</code> <code>A</code> in an efficient manner. For array types that have opted into fast linear indexing (like <code>Array</code>), this is simply the range <code>1:length(A)</code>. For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</p><p>If you supply more than one <code>AbstractArray</code> argument, <code>eachindex</code> will create an iterable object that is fast for all arguments (a <code>UnitRange</code> if all inputs have fast linear indexing, a <a href="#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a> otherwise). If the arrays have different sizes and/or dimensionalities, <code>eachindex</code> will return an iterable that spans the largest range along each dimension.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4];

julia&gt; for i in eachindex(A) # linear indexing
           println(i)
       end
1
2
3
4

julia&gt; for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing
           println(i)
       end
CartesianIndex(1, 1)
CartesianIndex(2, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L175-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IndexStyle" href="#Base.IndexStyle"><code>Base.IndexStyle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IndexStyle(A)
IndexStyle(typeof(A))</code></pre><p><code>IndexStyle</code> specifies the &quot;native indexing style&quot; for array <code>A</code>. When you define a new <code>AbstractArray</code> type, you can choose to implement either linear indexing or cartesian indexing.  If you decide to implement linear indexing, then you must set this trait for your array type:</p><pre><code class="language-none">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p>The default is <code>IndexCartesian()</code>.</p><p>Julia&#39;s internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</p><p>If you define both styles of indexing for your <code>AbstractArray</code>, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, <a href="#Base.eachindex"><code>eachindex</code></a> creates an iterator whose type depends on the setting of this trait.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/indices.jl#L13-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.conj!" href="#Base.conj!"><code>Base.conj!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">conj!(A)</code></pre><p>Transform an array to its complex conjugate in-place.</p><p>See also <a href="../math/#Base.conj"><code>conj</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1+im 2-im; 2+2im 3+im]
2×2 Array{Complex{Int64},2}:
 1+1im  2-1im
 2+2im  3+1im

julia&gt; conj!(A);

julia&gt; A
2×2 Array{Complex{Int64},2}:
 1-1im  2+1im
 2-2im  3-1im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/arraymath.jl#L5-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.stride" href="#Base.stride"><code>Base.stride</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stride(A, k::Integer)</code></pre><p>Return the distance in memory (in number of elements) between adjacent elements in dimension <code>k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = fill(1, (3,4,5));

julia&gt; stride(A,2)
3

julia&gt; stride(A,3)
12</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L334-L349">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.strides" href="#Base.strides"><code>Base.strides</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strides(A)</code></pre><p>Return a tuple of the memory strides in each dimension.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = fill(1, (3,4,5));

julia&gt; strides(A)
(1, 3, 12)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L319-L331">source</a></section><h2><a class="nav-anchor" id="广播和向量化-1" href="#广播和向量化-1">广播和向量化</a></h2><!-- ## Broadcast and vectorization --><p>参见<a href="base/@ref man-vectorized">dot syntax for vectorizing functions</a>；例如，<code>f.(args...)</code>隐式 调用了 <code>broadcast(f, args...)</code> 。与其依赖类似于作用在数组上的<code>sin</code>这样的“向量化的”函数方法，你应当使用 <code>sin.(a)</code>来通过<code>broadcast</code>向量化这个操作。</p><!-- See also the [dot syntax for vectorizing functions](@ref man-vectorized);
for example, `f.(args...)` implicitly calls `broadcast(f, args...)`.
Rather than relying on "vectorized" methods of functions like `sin`
to operate on arrays, you should use `sin.(a)` to vectorize via `broadcast`. --><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.broadcast" href="#Base.Broadcast.broadcast"><code>Base.Broadcast.broadcast</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">broadcast(f, As...)</code></pre><p>Broadcast the function <code>f</code> over the arrays, tuples, collections, <a href="../c/#Core.Ref"><code>Ref</code></a>s and/or scalars <code>As</code>.</p><p>Broadcasting applies the function <code>f</code> over the elements of the container arguments and the scalars themselves in <code>As</code>. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including <code>Number</code>s, <code>String</code>s, <code>Symbol</code>s, <code>Type</code>s, <code>Function</code>s and some common singletons like <a href="../base/#Base.missing"><code>missing</code></a> and <a href="../constants/#Core.nothing"><code>nothing</code></a>. All other arguments are iterated over or indexed into elementwise.</p><p>The resulting container type is established by the following rules:</p><ul><li>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</li><li>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</li><li>All other combinations of arguments default to returning an <code>Array</code>, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.</li></ul><p>A special syntax exists for broadcasting: <code>f.(args...)</code> is equivalent to <code>broadcast(f, args...)</code>, and nested <code>f.(g.(args...))</code> calls are fused into a single broadcast loop.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia&gt; broadcast(+, A, B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia&gt; parse.(Int, [&quot;1&quot;, &quot;2&quot;])
2-element Array{Int64,1}:
 1
 2

julia&gt; abs.((1, -2))
(1, 2)

julia&gt; broadcast(+, 1.0, (0, -2.0))
(1.0, -1.0)

julia&gt; (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))
2-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]

julia&gt; string.((&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;), &quot;: &quot;, 1:4)
4-element Array{String,1}:
 &quot;one: 1&quot;
 &quot;two: 2&quot;
 &quot;three: 3&quot;
 &quot;four: 4&quot;
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/broadcast.jl#L631-L706">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.broadcast!" href="#Base.Broadcast.broadcast!"><code>Base.Broadcast.broadcast!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">broadcast!(f, dest, As...)</code></pre><p>Like <a href="#Base.Broadcast.broadcast"><code>broadcast</code></a>, but store the result of <code>broadcast(f, As...)</code> in the <code>dest</code> array. Note that <code>dest</code> is only used to store the result, and does not supply arguments to <code>f</code> unless it is also listed in the <code>As</code>, as in <code>broadcast!(f, A, A, B)</code> to perform <code>A[:] = broadcast(f, A, B)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/broadcast.jl#L713-L721">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.@__dot__" href="#Base.Broadcast.@__dot__"><code>Base.Broadcast.@__dot__</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@. expr</code></pre><p>Convert every function call or operator in <code>expr</code> into a &quot;dot call&quot; (e.g. convert <code>f(x)</code> to <code>f.(x)</code>), and convert every assignment in <code>expr</code> to a &quot;dot assignment&quot; (e.g. convert <code>+=</code> to <code>.+=</code>).</p><p>If you want to <em>avoid</em> adding dots for selected function calls in <code>expr</code>, splice those function calls in with <code>$</code>.  For example, <code>@. sqrt(abs($sort(x)))</code> is equivalent to <code>sqrt.(abs.(sort(x)))</code> (no dot for <code>sort</code>).</p><p>(<code>@.</code> is equivalent to a call to <code>@__dot__</code>.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = 1.0:3.0; y = similar(x);

julia&gt; @. y = x + 3 * sin(x)
3-element Array{Float64,1}:
 3.5244129544236893
 4.727892280477045
 3.4233600241796016</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/broadcast.jl#L1099-L1123">source</a></section><p>For specializing broadcast on custom types, see</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.BroadcastStyle" href="#Base.Broadcast.BroadcastStyle"><code>Base.Broadcast.BroadcastStyle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>BroadcastStyle</code> is an abstract type and trait-function used to determine behavior of objects under broadcasting. <code>BroadcastStyle(typeof(x))</code> returns the style associated with <code>x</code>. To customize the broadcasting behavior of a type, one can declare a style by defining a type/method pair</p><pre><code class="language-none">struct MyContainerStyle &lt;: BroadcastStyle end
Base.BroadcastStyle(::Type{&lt;:MyContainer}) = MyContainerStyle()</code></pre><p>One then writes method(s) (at least <a href="#Base.similar"><code>similar</code></a>) operating on <code>Broadcasted{MyContainerStyle}</code>. There are also several pre-defined subtypes of <code>BroadcastStyle</code> that you may be able to leverage; see the <a href="base/@ref man-interfaces-broadcasting">Interfaces chapter</a> for more information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/broadcast.jl#L18-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.broadcast_axes" href="#Base.Broadcast.broadcast_axes"><code>Base.Broadcast.broadcast_axes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Base.broadcast_axes(A)</code></pre><p>Compute the axes for <code>A</code>.</p><p>This should only be specialized for objects that do not define <a href="#Base.axes-Tuple{Any}"><code>axes</code></a> but want to participate in broadcasting.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/broadcast.jl#L207-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.AbstractArrayStyle" href="#Base.Broadcast.AbstractArrayStyle"><code>Base.Broadcast.AbstractArrayStyle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Broadcast.AbstractArrayStyle{N} &lt;: BroadcastStyle</code> is the abstract supertype for any style associated with an <code>AbstractArray</code> type. The <code>N</code> parameter is the dimensionality, which can be handy for AbstractArray types that only support specific dimensionalities:</p><pre><code class="language-none">struct SparseMatrixStyle &lt;: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{&lt;:SparseMatrixCSC}) = SparseMatrixStyle()</code></pre><p>For <code>AbstractArray</code> types that support arbitrary dimensionality, <code>N</code> can be set to <code>Any</code>:</p><pre><code class="language-none">struct MyArrayStyle &lt;: Broadcast.AbstractArrayStyle{Any} end
Base.BroadcastStyle(::Type{&lt;:MyArray}) = MyArrayStyle()</code></pre><p>In cases where you want to be able to mix multiple <code>AbstractArrayStyle</code>s and keep track of dimensionality, your style needs to support a <a href="../base/#Base.Val"><code>Val</code></a> constructor:</p><pre><code class="language-none">struct MyArrayStyleDim{N} &lt;: Broadcast.AbstractArrayStyle{N} end
(::Type{&lt;:MyArrayStyleDim})(::Val{N}) where N = MyArrayStyleDim{N}()</code></pre><p>Note that if two or more <code>AbstractArrayStyle</code> subtypes conflict, broadcasting machinery will fall back to producing <code>Array</code>s. If this is undesirable, you may need to define binary <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> rules to control the output type.</p><p>See also <a href="#Base.Broadcast.DefaultArrayStyle"><code>Broadcast.DefaultArrayStyle</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/broadcast.jl#L48-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.ArrayStyle" href="#Base.Broadcast.ArrayStyle"><code>Base.Broadcast.ArrayStyle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Broadcast.ArrayStyle{MyArrayType}()</code> is a <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> indicating that an object behaves as an array for broadcasting. It presents a simple way to construct <a href="#Base.Broadcast.AbstractArrayStyle"><code>Broadcast.AbstractArrayStyle</code></a>s for specific <code>AbstractArray</code> container types. Broadcast styles created this way lose track of dimensionality; if keeping track is important for your type, you should create your own custom <a href="#Base.Broadcast.AbstractArrayStyle"><code>Broadcast.AbstractArrayStyle</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/broadcast.jl#L76-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.DefaultArrayStyle" href="#Base.Broadcast.DefaultArrayStyle"><code>Base.Broadcast.DefaultArrayStyle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Broadcast.DefaultArrayStyle{N}()</code> is a <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> indicating that an object behaves as an <code>N</code>-dimensional array for broadcasting. Specifically, <code>DefaultArrayStyle</code> is used for any <code>AbstractArray</code> type that hasn&#39;t defined a specialized style, and in the absence of overrides from other <code>broadcast</code> arguments the resulting output type is <code>Array</code>. When there are multiple inputs to <code>broadcast</code>, <code>DefaultArrayStyle</code> &quot;loses&quot; to any other <a href="#Base.Broadcast.ArrayStyle"><code>Broadcast.ArrayStyle</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/broadcast.jl#L86-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.broadcastable" href="#Base.Broadcast.broadcastable"><code>Base.Broadcast.broadcastable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Broadcast.broadcastable(x)</code></pre><p>Return either <code>x</code> or an object like <code>x</code> such that it supports <a href="#Base.axes-Tuple{Any}"><code>axes</code></a>, indexing, and its type supports <a href="#Base.ndims"><code>ndims</code></a>.</p><p>If <code>x</code> supports iteration, the returned value should have the same <code>axes</code> and indexing behaviors as <a href="../collections/#Base.collect-Tuple{Any}"><code>collect(x)</code></a>.</p><p>If <code>x</code> is not an <code>AbstractArray</code> but it supports <code>axes</code>, indexing, and its type supports <code>ndims</code>, then <code>broadcastable(::typeof(x))</code> may be implemented to just return itself. Further, if <code>x</code> defines its own <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a>, then it must define its <code>broadcastable</code> method to return itself for the custom style to have any effect.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Broadcast.broadcastable([1,2,3]) # like `identity` since arrays already support axes and indexing
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; Broadcast.broadcastable(Int) # Types don&#39;t support axes, indexing, or iteration but are commonly used as scalars
Base.RefValue{Type{Int64}}(Int64)

julia&gt; Broadcast.broadcastable(&quot;hello&quot;) # Strings break convention of matching iteration and act like a scalar instead
Base.RefValue{String}(&quot;hello&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/broadcast.jl#L581-L608">source</a></section><h2><a class="nav-anchor" id="索引和赋值-1" href="#索引和赋值-1">索引和赋值</a></h2><!-- ## Indexing and assignment --><pre><code class="language-none">Base.getindex(::AbstractArray, ::Any...)
Base.setindex!(::AbstractArray, ::Any, ::Any...)
Base.copyto!(::AbstractArray, ::CartesianIndices, ::AbstractArray, ::CartesianIndices)
Base.isassigned
Base.Colon
Base.CartesianIndex
Base.CartesianIndices
Base.Dims
Base.LinearIndices
Base.to_indices
Base.checkbounds
Base.checkindex</code></pre><h2><a class="nav-anchor" id="查看（Views，SubArrays和其它查看类型）-1" href="#查看（Views，SubArrays和其它查看类型）-1">查看（Views，SubArrays和其它查看类型）</a></h2><!-- ## Views (SubArrays and other view types) --><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.view" href="#Base.view"><code>Base.view</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">view(A, inds...)</code></pre><p>Like <a href="../collections/#Base.getindex"><code>getindex</code></a>, but returns a view into the parent array <code>A</code> with the given indices instead of making a copy.  Calling <a href="../collections/#Base.getindex"><code>getindex</code></a> or <a href="../collections/#Base.setindex!"><code>setindex!</code></a> on the returned <code>SubArray</code> computes the indices to the parent array on the fly without checking bounds.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = view(A, :, 1)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 3

julia&gt; fill!(b, 0)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 0
 0

julia&gt; A # Note A has changed even though we modified b
2×2 Array{Int64,2}:
 0  2
 0  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/subarray.jl#L100-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@view" href="#Base.@view"><code>Base.@view</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@view A[inds...]</code></pre><p>Creates a <code>SubArray</code> from an indexing expression. This can only be applied directly to a reference expression (e.g. <code>@view A[1,2:end]</code>), and should <em>not</em> be used as the target of an assignment (e.g. <code>@view(A[1,2:end]) = ...</code>).  See also <a href="#Base.@views"><code>@views</code></a> to switch an entire block of code to use views for slicing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = @view A[:, 1]
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 3

julia&gt; fill!(b, 0)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 0
 0

julia&gt; A
2×2 Array{Int64,2}:
 0  2
 0  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/views.jl#L72-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@views" href="#Base.@views"><code>Base.@views</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@views expression</code></pre><p>Convert every array-slicing operation in the given expression (which may be a <code>begin</code>/<code>end</code> block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit <code>getindex</code> calls (as opposed to <code>array[...]</code>) are unaffected.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <code>@views</code> macro only affects <code>array[...]</code> expressions that appear explicitly in the given <code>expression</code>, not array slicing that occurs in functions called by that code.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = zeros(3, 3);

julia&gt; @views for row in 1:3
           b = A[row, :]
           b[:] .= row
       end

julia&gt; A
3×3 Array{Float64,2}:
 1.0  1.0  1.0
 2.0  2.0  2.0
 3.0  3.0  3.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/views.jl#L183-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parent(A)</code></pre><p>Returns the &quot;parent array&quot; of an array view type (e.g., <code>SubArray</code>), or the array itself if it is not a view.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; V = view(A, 1:2, :)
2×2 view(::Array{Int64,2}, 1:2, :) with eltype Int64:
 1  2
 3  4

julia&gt; parent(V)
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L1045-L1068">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parentindices" href="#Base.parentindices"><code>Base.parentindices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parentindices(A)</code></pre><p>From an array view <code>A</code>, returns the corresponding indices in the parent.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/subarray.jl#L66-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.selectdim" href="#Base.selectdim"><code>Base.selectdim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">selectdim(A, d::Integer, i)</code></pre><p>Return a view of all the data of <code>A</code> where the index for dimension <code>d</code> equals <code>i</code>.</p><p>Equivalent to <code>view(A,:,:,...,i,:,:,...)</code> where <code>i</code> is in position <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3 4; 5 6 7 8]
2×4 Array{Int64,2}:
 1  2  3  4
 5  6  7  8

julia&gt; selectdim(A, 2, 3)
2-element view(::Array{Int64,2}, :, 3) with eltype Int64:
 3
 7</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarraymath.jl#L103-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reinterpret" href="#Base.reinterpret"><code>Base.reinterpret</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reinterpret(type, A)</code></pre><p>Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, <code>reinterpret(Float32, UInt32(7))</code> interprets the 4 bytes corresponding to <code>UInt32(7)</code> as a <a href="../numbers/#Core.Float32"><code>Float32</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; reinterpret(Float32, UInt32(7))
1.0f-44

julia&gt; reinterpret(Float32, UInt32[1 2 3 4 5])
1×5 reinterpret(Float32, ::Array{UInt32,2}):
 1.4013e-45  2.8026e-45  4.2039e-45  5.60519e-45  7.00649e-45</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/essentials.jl#L324-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reshape" href="#Base.reshape"><code>Base.reshape</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reshape(A, dims...) -&gt; AbstractArray
reshape(A, dims) -&gt; AbstractArray</code></pre><p>Return an array with the same data as <code>A</code>, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that the result is mutable if and only if <code>A</code> is mutable, and setting elements of one alters the values of the other.</p><p>The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a <code>:</code>, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array <code>A</code>. The total number of elements must not change.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Vector(1:16)
16-element Array{Int64,1}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16

julia&gt; reshape(A, (4, 4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; reshape(A, 2, :)
2×8 Array{Int64,2}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16

julia&gt; reshape(1:6, 2, 3)
2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:
 1  3  5
 2  4  6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/reshapedarray.jl#L38-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.squeeze" href="#Base.squeeze"><code>Base.squeeze</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">squeeze(A; dims)</code></pre><p>Remove the dimensions specified by <code>dims</code> from array <code>A</code>. Elements of <code>dims</code> must be unique and within the range <code>1:ndims(A)</code>. <code>size(A,i)</code> must equal 1 for all <code>i</code> in <code>dims</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = reshape(Vector(1:4),(2,2,1,1))
2×2×1×1 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

julia&gt; squeeze(a; dims=3)
2×2×1 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarraymath.jl#L49-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.vec" href="#Base.vec"><code>Base.vec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vec(a::AbstractArray) -&gt; AbstractVector</code></pre><p>Reshape the array <code>a</code> as a one-dimensional column vector. Return <code>a</code> if it is already an <code>AbstractVector</code>. The resulting array shares the same underlying data as <code>a</code>, so it will only be mutable if <code>a</code> is mutable, in which case modifying one will also modify the other.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; vec(a)
6-element Array{Int64,1}:
 1
 4
 2
 5
 3
 6

julia&gt; vec(1:3)
1:3</code></pre><p>See also <a href="#Base.reshape"><code>reshape</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarraymath.jl#L12-L41">source</a></section><h2><a class="nav-anchor" id="连接和置换-1" href="#连接和置换-1">连接和置换</a></h2><!-- ## Concatenation and permutation --><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cat" href="#Base.cat"><code>Base.cat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cat(A...; dims=dims)</code></pre><p>Concatenate the input arrays along the specified dimensions in the iterable <code>dims</code>. For dimensions not in <code>dims</code>, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in <code>dims</code>, the size of the output array is the sum of the sizes of the input arrays along that dimension. If <code>dims</code> is a single number, the different arrays are tightly stacked along that dimension. If <code>dims</code> is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, <code>cat(matrices...; dims=(1,2))</code> builds a block diagonal matrix, i.e. a block matrix with <code>matrices[1]</code>, <code>matrices[2]</code>, ... as diagonal blocks and matching zero blocks away from the diagonal.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L1473-L1487">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vcat(A...)</code></pre><p>Concatenate along dimension 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia&gt; b = [6 7 8 9 10; 11 12 13 14 15]
2×5 Array{Int64,2}:
  6   7   8   9  10
 11  12  13  14  15

julia&gt; vcat(a,b)
3×5 Array{Int64,2}:
  1   2   3   4   5
  6   7   8   9  10
 11  12  13  14  15

julia&gt; c = ([1 2 3], [4 5 6])
([1 2 3], [4 5 6])

julia&gt; vcat(c...)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L1395-L1425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hcat(A...)</code></pre><p>Concatenate along dimension 2.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1; 2; 3; 4; 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; b = [6 7; 8 9; 10 11; 12 13; 14 15]
5×2 Array{Int64,2}:
  6   7
  8   9
 10  11
 12  13
 14  15

julia&gt; hcat(a,b)
5×3 Array{Int64,2}:
 1   6   7
 2   8   9
 3  10  11
 4  12  13
 5  14  15

julia&gt; c = ([1; 2; 3], [4; 5; 6])
([1, 2, 3], [4, 5, 6])

julia&gt; hcat(c...)
3×2 Array{Int64,2}:
 1  4
 2  5
 3  6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L1427-L1467">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hvcat" href="#Base.hvcat"><code>Base.hvcat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hvcat(rows::Tuple{Vararg{Int}}, values...)</code></pre><p>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia&gt; [a b c; d e f]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; hvcat((3,3), a,b,c,d,e,f)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; [a b;c d; e f]
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6

julia&gt; hvcat((2,2,2), a,b,c,d,e,f)
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6</code></pre><p>If the first argument is a single integer <code>n</code>, then all block rows are assumed to have <code>n</code> block columns.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L1518-L1555">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.vect" href="#Base.vect"><code>Base.vect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">vect(X...)</code></pre><p>Create a <a href="#Base.Vector"><code>Vector</code></a> with element type computed from the <code>promote_typeof</code> of the argument, containing the argument list.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Base.vect(UInt8(1), 2.5, 1//2)
3-element Array{Float64,1}:
 1.0
 2.5
 0.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L107-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.circshift" href="#Base.circshift"><code>Base.circshift</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">circshift(A, shifts)</code></pre><p>Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = reshape(Vector(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; circshift(b, (0,2))
4×4 Array{Int64,2}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia&gt; circshift(b, (-1,0))
4×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13

julia&gt; a = BitArray([true, true, false, false, true])
5-element BitArray{1}:
  true
  true
 false
 false
  true

julia&gt; circshift(a, 1)
5-element BitArray{1}:
  true
  true
  true
 false
 false

julia&gt; circshift(a, -1)
5-element BitArray{1}:
  true
 false
 false
  true
  true</code></pre><p>See also <a href="#Base.circshift!"><code>circshift!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarraymath.jl#L185-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.circshift!" href="#Base.circshift!"><code>Base.circshift!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">circshift!(dest, src, shifts)</code></pre><p>Circularly shift, i.e. rotate, the data in <code>src</code>, storing the result in <code>dest</code>. <code>shifts</code> specifies the amount to shift in each dimension.</p><p>The <code>dest</code> array must be distinct from the <code>src</code> array (they cannot alias each other).</p><p>See also <a href="#Base.circshift"><code>circshift</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/multidimensional.jl#L868-L878">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.circcopy!" href="#Base.circcopy!"><code>Base.circcopy!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">circcopy!(dest, src)</code></pre><p>Copy <code>src</code> to <code>dest</code>, indexing each dimension modulo its length. <code>src</code> and <code>dest</code> must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap <code>dest</code> agrees with <code>src</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; src = reshape(Vector(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; dest = OffsetArray{Int}(undef, (0:3,2:5))

julia&gt; circcopy!(dest, src)
OffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:
 8  12  16  4
 5   9  13  1
 6  10  14  2
 7  11  15  3

julia&gt; dest[1:3,2:4] == src[1:3,2:4]
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/multidimensional.jl#L921-L951">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findall-Tuple{Any}" href="#Base.findall-Tuple{Any}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findall(A)</code></pre><p>Return a vector <code>I</code> of the <code>true</code> indices or keys of <code>A</code>. If there are no such elements of <code>A</code>, return an empty array. To search for other kinds of values, pass a predicate as the first argument.</p><p>Indices or keys are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [true, false, false, true]
4-element Array{Bool,1}:
  true
 false
 false
  true

julia&gt; findall(A)
2-element Array{Int64,1}:
 1
 4

julia&gt; A = [true false; false true]
2×2 Array{Bool,2}:
  true  false
 false   true

julia&gt; findall(A)
2-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 2)

julia&gt; findall(falses(3))
0-element Array{Int64,1}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1970-L2007">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findall-Tuple{Function,Any}" href="#Base.findall-Tuple{Function,Any}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findall(f::Function, A)</code></pre><p>Return a vector <code>I</code> of the indices or keys of <code>A</code> where <code>f(A[I])</code> returns <code>true</code>. If there are no such elements of <code>A</code>, return an empty array.</p><p>Indices or keys are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = [1, 3, 4]
3-element Array{Int64,1}:
 1
 3
 4

julia&gt; findall(isodd, x)
2-element Array{Int64,1}:
 1
 2

julia&gt; A = [1 2 0; 3 4 0]
2×3 Array{Int64,2}:
 1  2  0
 3  4  0
julia&gt; findall(isodd, A)
2-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)

julia&gt; findall(!iszero, A)
4-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)

julia&gt; d = Dict(:A =&gt; 10, :B =&gt; -1, :C =&gt; 0)
Dict{Symbol,Int64} with 3 entries:
  :A =&gt; 10
  :B =&gt; -1
  :C =&gt; 0

julia&gt; findall(x -&gt; x &gt;= 0, d)
2-element Array{Symbol,1}:
 :A
 :C
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1917-L1967">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findfirst-Tuple{Any}" href="#Base.findfirst-Tuple{Any}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findfirst(A)</code></pre><p>Return the index or key of the first <code>true</code> value in <code>A</code>. Return <code>nothing</code> if no such value is found. To search for other kinds of values, pass a predicate as the first argument.</p><p>Indices or keys are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [false, false, true, false]
4-element Array{Bool,1}:
 false
 false
  true
 false

julia&gt; findfirst(A)
3

julia&gt; findfirst(falses(3)) # returns nothing, but not printed in the REPL

julia&gt; A = [false false; true false]
2×2 Array{Bool,2}:
 false  false
  true  false

julia&gt; findfirst(A)
CartesianIndex(2, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1599-L1631">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findfirst-Tuple{Function,Any}" href="#Base.findfirst-Tuple{Function,Any}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findfirst(predicate::Function, A)</code></pre><p>Return the index or key of the first element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Return <code>nothing</code> if there is no such element.</p><p>Indices or keys are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 4, 2, 2]
4-element Array{Int64,1}:
 1
 4
 2
 2

julia&gt; findfirst(iseven, A)
2

julia&gt; findfirst(x -&gt; x&gt;10, A) # returns nothing, but not printed in the REPL

julia&gt; findfirst(isequal(4), A)
2

julia&gt; A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia&gt; findfirst(iseven, A)
CartesianIndex(2, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1687-L1721">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findlast-Tuple{Any}" href="#Base.findlast-Tuple{Any}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findlast(A)</code></pre><p>Return the index or key of the last <code>true</code> value in <code>A</code>. Return <code>nothing</code> if there is no <code>true</code> value in <code>A</code>.</p><p>Indices or keys are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [true, false, true, false]
4-element Array{Bool,1}:
  true
 false
  true
 false

julia&gt; findlast(A)
3

julia&gt; A = falses(2,2);

julia&gt; findlast(A) # returns nothing, but not printed in the REPL

julia&gt; A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia&gt; findlast(A)
CartesianIndex(2, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1780-L1813">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findlast-Tuple{Function,Any}" href="#Base.findlast-Tuple{Function,Any}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findlast(predicate::Function, A)</code></pre><p>Return the index or key of the last element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Return <code>nothing</code> if there is no such element.</p><p>Indices or keys are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; findlast(isodd, A)
3

julia&gt; findlast(x -&gt; x &gt; 5, A) # returns nothing, but not printed in the REPL

julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; findlast(isodd, A)
CartesianIndex(2, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1874-L1905">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findnext-Tuple{Any,Integer}" href="#Base.findnext-Tuple{Any,Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findnext(A, i)</code></pre><p>Find the next index after or including <code>i</code> of a <code>true</code> element of <code>A</code>, or <code>nothing</code> if not found.</p><p>Indices are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [false, false, true, false]
4-element Array{Bool,1}:
 false
 false
  true
 false

julia&gt; findnext(A, 1)
3

julia&gt; findnext(A, 4) # returns nothing, but not printed in the REPL

julia&gt; A = [false false; true false]
2×2 Array{Bool,2}:
 false  false
  true  false

julia&gt; findnext(A, CartesianIndex(1, 1))
CartesianIndex(2, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1549-L1580">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findnext-Tuple{Function,Any,Integer}" href="#Base.findnext-Tuple{Function,Any,Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findnext(predicate::Function, A, i)</code></pre><p>Find the next index after or including <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>nothing</code> if not found.</p><p>Indices are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 4, 2, 2];

julia&gt; findnext(isodd, A, 1)
1

julia&gt; findnext(isodd, A, 2) # returns nothing, but not printed in the REPL

julia&gt; A = [1 4; 2 2];

julia&gt; findnext(isodd, A, CartesianIndex(1, 1))
CartesianIndex(1, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1649-L1672">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findprev-Tuple{Any,Integer}" href="#Base.findprev-Tuple{Any,Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findprev(A, i)</code></pre><p>Find the previous index before or including <code>i</code> of a <code>true</code> element of <code>A</code>, or <code>nothing</code> if not found.</p><p>Indices are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [false, false, true, true]
4-element Array{Bool,1}:
 false
 false
  true
  true

julia&gt; findprev(A, 3)
3

julia&gt; findprev(A, 1) # returns nothing, but not printed in the REPL

julia&gt; A = [false false; true true]
2×2 Array{Bool,2}:
 false  false
  true   true

julia&gt; findprev(A, CartesianIndex(2, 1))
CartesianIndex(2, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1733-L1764">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findprev-Tuple{Function,Any,Integer}" href="#Base.findprev-Tuple{Function,Any,Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findprev(predicate::Function, A, i)</code></pre><p>Find the previous index before or including <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>nothing</code> if not found.</p><p>Indices are of the same type as those returned by <a href="../collections/#Base.keys"><code>keys(A)</code></a> and <a href="../collections/#Base.pairs"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4, 6, 1, 2]
4-element Array{Int64,1}:
 4
 6
 1
 2

julia&gt; findprev(isodd, A, 1) # returns nothing, but not printed in the REPL

julia&gt; findprev(isodd, A, 3)
3

julia&gt; A = [4 6; 1 2]
2×2 Array{Int64,2}:
 4  6
 1  2

julia&gt; findprev(isodd, A, CartesianIndex(1, 2))
CartesianIndex(2, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1831-L1862">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.permutedims" href="#Base.permutedims"><code>Base.permutedims</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">permutedims(A::AbstractArray, perm)</code></pre><p>Permute the dimensions of array <code>A</code>. <code>perm</code> is a vector specifying a permutation of length <code>ndims(A)</code>.</p><p>See also: <a href="#Base.PermutedDimsArrays.PermutedDimsArray"><code>PermutedDimsArray</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = reshape(Vector(1:8), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia&gt; permutedims(A, [3, 2, 1])
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 5  7

[:, :, 2] =
 2  4
 6  8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/permuteddimsarray.jl#L80-L110">source</a><div><div><pre><code class="language-none">permutedims(m::AbstractMatrix)</code></pre><p>Permute the dimensions of the matrix <code>m</code>, by flipping the elements across the diagonal of the matrix. Differs from <code>LinearAlgebra</code>&#39;s <a href="base/@ref"><code>transpose</code></a> in that the operation is not recursive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4];

julia&gt; b = [5 6; 7 8];

julia&gt; c = [9 10; 11 12];

julia&gt; d = [13 14; 15 16];

julia&gt; X = [[a] [b]; [c] [d]]
2×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]     [5 6; 7 8]
 [9 10; 11 12]  [13 14; 15 16]

julia&gt; permutedims(X)
2×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]  [9 10; 11 12]
 [5 6; 7 8]  [13 14; 15 16]

julia&gt; transpose(X)
2×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},2}}:
 [1 3; 2 4]  [9 11; 10 12]
 [5 7; 6 8]  [13 15; 14 16]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/permuteddimsarray.jl#L116-L148">source</a><div><div><pre><code class="language-none">permutedims(v::AbstractVector)</code></pre><p>Reshape vector <code>v</code> into a <code>1 × length(v)</code> row matrix. Differs from <code>LinearAlgebra</code>&#39;s <a href="base/@ref"><code>transpose</code></a> in that the operation is not recursive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; permutedims([1, 2, 3, 4])
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; V = [[[1 2; 3 4]]; [[5 6; 7 8]]]
2-element Array{Array{Int64,2},1}:
 [1 2; 3 4]
 [5 6; 7 8]

julia&gt; permutedims(V)
1×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]  [5 6; 7 8]

julia&gt; transpose(V)
1×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},1}}:
 [1 3; 2 4]  [5 7; 6 8]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/permuteddimsarray.jl#L151-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.permutedims!" href="#Base.permutedims!"><code>Base.permutedims!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">permutedims!(dest, src, perm)</code></pre><p>Permute the dimensions of array <code>src</code> and store the result in the array <code>dest</code>. <code>perm</code> is a vector specifying a permutation of length <code>ndims(src)</code>. The preallocated array <code>dest</code> should have <code>size(dest) == size(src)[perm]</code> and is completely overwritten. No in-place permutation is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p><p>See also <a href="#Base.permutedims"><code>permutedims</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/permuteddimsarray.jl#L180-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.PermutedDimsArrays.PermutedDimsArray" href="#Base.PermutedDimsArrays.PermutedDimsArray"><code>Base.PermutedDimsArrays.PermutedDimsArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PermutedDimsArray(A, perm) -&gt; B</code></pre><p>Given an AbstractArray <code>A</code>, create a view <code>B</code> such that the dimensions appear to be permuted. Similar to <code>permutedims</code>, except that no copying occurs (<code>B</code> shares storage with <code>A</code>).</p><p>See also: <a href="#Base.permutedims"><code>permutedims</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = rand(3,5,4);

julia&gt; B = PermutedDimsArray(A, (3,1,2));

julia&gt; size(B)
(4, 3, 5)

julia&gt; B[3,1,2] == A[1,2,3]
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/permuteddimsarray.jl#L20-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.promote_shape" href="#Base.promote_shape"><code>Base.promote_shape</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">promote_shape(s1, s2)</code></pre><p>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = fill(1, (3,4,1,1,1));

julia&gt; b = fill(1, (3,4));

julia&gt; promote_shape(a,b)
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia&gt; promote_shape((2,3,1,4), (2, 3, 1, 4, 1))
(2, 3, 1, 4, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/indices.jl#L77-L95">source</a></section><h2><a class="nav-anchor" id="数组函数-1" href="#数组函数-1">数组函数</a></h2><!-- ## Array functions --><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.accumulate" href="#Base.accumulate"><code>Base.accumulate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">accumulate(op, A; dims::Integer, [init])</code></pre><p>Cumulative operation <code>op</code> along the dimension <code>dims</code> of <code>A</code> (providing <code>dims</code> is optional for vectors). An inital value <code>init</code> may optionally be privided by a keyword argument. See also <a href="#Base.accumulate!"><code>accumulate!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of <code>accumulate</code>, see: <a href="#Base.cumsum"><code>cumsum</code></a>, <a href="#Base.cumprod"><code>cumprod</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; accumulate(+, [1,2,3])
3-element Array{Int64,1}:
 1
 3
 6

julia&gt; accumulate(*, [1,2,3])
3-element Array{Int64,1}:
 1
 2
 6

julia&gt; accumulate(+, [1,2,3]; init=100)
3-element Array{Int64,1}:
 101
 103
 106

julia&gt; accumulate(min, [1,2,-1]; init=0)
3-element Array{Int64,1}:
  0
  0
 -1

julia&gt; accumulate(+, fill(1, 3, 3), dims=1)
3×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3

julia&gt; accumulate(+, fill(1, 3, 3), dims=2)
3×3 Array{Int64,2}:
 1  2  3
 1  2  3
 1  2  3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/accumulate.jl#L198-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.accumulate!" href="#Base.accumulate!"><code>Base.accumulate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">accumulate!(op, B, A; [dims], [init])</code></pre><p>Cumulative operation <code>op</code> on <code>A</code> along the dimension <code>dims</code>, storing the result in <code>B</code>. Providing <code>dims</code> is optional for vectors.  If the keyword argument <code>init</code> is given, its value is used to instantiate the accumulation. See also <a href="#Base.accumulate"><code>accumulate</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = [1, 0, 2, 0, 3];

julia&gt; y = [0, 0, 0, 0, 0];

julia&gt; accumulate!(+, y, x);

julia&gt; y
5-element Array{Int64,1}:
 1
 1
 3
 3
 6

julia&gt; A = [1 2; 3 4];

julia&gt; B = [0 0; 0 0];

julia&gt; accumulate!(-, B, A, dims=1);

julia&gt; B
2×2 Array{Int64,2}:
  1   2
 -2  -2

julia&gt; accumulate!(-, B, A, dims=2);

julia&gt; B
2×2 Array{Int64,2}:
 1  -1
 3  -1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/accumulate.jl#L258-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cumprod" href="#Base.cumprod"><code>Base.cumprod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cumprod(A; dims::Integer)</code></pre><p>Cumulative product along the dimension <code>dim</code>. See also <a href="#Base.cumprod!"><code>cumprod!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; cumprod(a, dims=1)
2×3 Array{Int64,2}:
 1   2   3
 4  10  18

julia&gt; cumprod(a, dims=2)
2×3 Array{Int64,2}:
 1   2    6
 4  20  120</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/accumulate.jl#L140-L164">source</a><div><div><pre><code class="language-none">cumprod(x::AbstractVector)</code></pre><p>Cumulative product of a vector. See also <a href="#Base.cumprod!"><code>cumprod!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cumprod(fill(1//2, 3))
3-element Array{Rational{Int64},1}:
 1//2
 1//4
 1//8

julia&gt; cumprod([fill(1//3, 2, 2) for i in 1:3])
3-element Array{Array{Rational{Int64},2},1}:
 [1//3 1//3; 1//3 1//3]
 [2//9 2//9; 2//9 2//9]
 [4//27 4//27; 4//27 4//27]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/accumulate.jl#L173-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cumprod!" href="#Base.cumprod!"><code>Base.cumprod!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cumprod!(B, A; dims::Integer)</code></pre><p>Cumulative product of <code>A</code> along the dimension <code>dims</code>, storing the result in <code>B</code>. See also <a href="#Base.cumprod"><code>cumprod</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/accumulate.jl#L123-L128">source</a><div><div><pre><code class="language-none">cumprod!(y::AbstractVector, x::AbstractVector)</code></pre><p>Cumulative product of a vector <code>x</code>, storing the result in <code>y</code>. See also <a href="#Base.cumprod"><code>cumprod</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/accumulate.jl#L132-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cumsum" href="#Base.cumsum"><code>Base.cumsum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cumsum(A; dims::Integer)</code></pre><p>Cumulative sum along the dimension <code>dims</code>. See also <a href="#Base.cumsum!"><code>cumsum!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; cumsum(a, dims=1)
2×3 Array{Int64,2}:
 1  2  3
 5  7  9

julia&gt; cumsum(a, dims=2)
2×3 Array{Int64,2}:
 1  3   6
 4  9  15</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/accumulate.jl#L64-L88">source</a><div><div><pre><code class="language-none">cumsum(x::AbstractVector)</code></pre><p>Cumulative sum a vector. See also <a href="#Base.cumsum!"><code>cumsum!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cumsum([1, 1, 1])
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; cumsum([fill(1, 2) for i in 1:3])
3-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]
 [3, 3]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/accumulate.jl#L98-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cumsum!" href="#Base.cumsum!"><code>Base.cumsum!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cumsum!(B, A; dims::Integer)</code></pre><p>Cumulative sum of <code>A</code> along the dimension <code>dims</code>, storing the result in <code>B</code>. See also <a href="#Base.cumsum"><code>cumsum</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/accumulate.jl#L41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.diff" href="#Base.diff"><code>Base.diff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diff(A::AbstractVector)
diff(A::AbstractMatrix; dims::Integer)</code></pre><p>Finite difference operator of matrix or vector <code>A</code>. If <code>A</code> is a matrix, specify the dimension over which to operate with the <code>dims</code> keyword argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [2 4; 6 16]
2×2 Array{Int64,2}:
 2   4
 6  16

julia&gt; diff(a, dims=2)
2×1 Array{Int64,2}:
  2
 10

julia&gt; diff(vec(a))
3-element Array{Int64,1}:
  4
 -2
 12</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/multidimensional.jl#L661-L686">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">repeat(A::AbstractArray, counts::Integer...)</code></pre><p>Construct an array by repeating array <code>A</code> a given number of times in each dimension, specified by <code>counts</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repeat([1, 2, 3], 2)
6-element Array{Int64,1}:
 1
 2
 3
 1
 2
 3

julia&gt; repeat([1, 2, 3], 2, 3)
6×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarraymath.jl#L248-L273">source</a><div><div><pre><code class="language-none">repeat(A::AbstractArray; inner=ntuple(x-&gt;1, ndims(A)), outer=ntuple(x-&gt;1, ndims(A)))</code></pre><p>Construct an array by repeating the entries of <code>A</code>. The i-th element of <code>inner</code> specifies the number of times that the individual entries of the i-th dimension of <code>A</code> should be repeated. The i-th element of <code>outer</code> specifies the number of times that a slice along the i-th dimension of <code>A</code> should be repeated. If <code>inner</code> or <code>outer</code> are omitted, no repetition is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repeat(1:2, inner=2)
4-element Array{Int64,1}:
 1
 1
 2
 2

julia&gt; repeat(1:2, outer=2)
4-element Array{Int64,1}:
 1
 2
 1
 2

julia&gt; repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))
4×6 Array{Int64,2}:
 1  2  1  2  1  2
 1  2  1  2  1  2
 3  4  3  4  3  4
 3  4  3  4  3  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarraymath.jl#L300-L332">source</a><div><div><pre><code class="language-none">repeat(s::AbstractString, r::Integer)</code></pre><p>Repeat a string <code>r</code> times. This can be written as <code>s^r</code>.</p><p>See also: <a href="math/#Base.:^-Tuple{Number,Number}"><code>^</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repeat(&quot;ha&quot;, 3)
&quot;hahaha&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/strings/basic.jl#L646-L658">source</a><div><div><pre><code class="language-none">repeat(c::AbstractChar, r::Integer) -&gt; String</code></pre><p>Repeat a character <code>r</code> times. This can equivalently be accomplished by calling <a href="math/#Base.:^-Tuple{Number,Number}"><code>c^r</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repeat(&#39;A&#39;, 3)
&quot;AAA&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/strings/string.jl#L349-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rot180" href="#Base.rot180"><code>Base.rot180</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rot180(A)</code></pre><p>Rotate matrix <code>A</code> 180 degrees.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rot180(a)
2×2 Array{Int64,2}:
 4  3
 2  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/arraymath.jl#L177-L194">source</a><div><div><pre><code class="language-none">rot180(A, k)</code></pre><p>Rotate matrix <code>A</code> 180 degrees an integer <code>k</code> number of times. If <code>k</code> is even, this is equivalent to a <code>copy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rot180(a,1)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rot180(a,2)
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/arraymath.jl#L279-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rotl90" href="#Base.rotl90"><code>Base.rotl90</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rotl90(A)</code></pre><p>Rotate matrix <code>A</code> left 90 degrees.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotl90(a)
2×2 Array{Int64,2}:
 2  4
 1  3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/arraymath.jl#L122-L139">source</a><div><div><pre><code class="language-none">rotl90(A, k)</code></pre><p>Rotate matrix <code>A</code> left 90 degrees an integer <code>k</code> number of times. If <code>k</code> is zero or a multiple of four, this is equivalent to a <code>copy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotl90(a,1)
2×2 Array{Int64,2}:
 2  4
 1  3

julia&gt; rotl90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rotl90(a,3)
2×2 Array{Int64,2}:
 3  1
 4  2

julia&gt; rotl90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/arraymath.jl#L204-L237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rotr90" href="#Base.rotr90"><code>Base.rotr90</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rotr90(A)</code></pre><p>Rotate matrix <code>A</code> right 90 degrees.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotr90(a)
2×2 Array{Int64,2}:
 3  1
 4  2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/arraymath.jl#L150-L167">source</a><div><div><pre><code class="language-none">rotr90(A, k)</code></pre><p>Rotate matrix <code>A</code> right 90 degrees an integer <code>k</code> number of times. If <code>k</code> is zero or a multiple of four, this is equivalent to a <code>copy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotr90(a,1)
2×2 Array{Int64,2}:
 3  1
 4  2

julia&gt; rotr90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rotr90(a,3)
2×2 Array{Int64,2}:
 2  4
 1  3

julia&gt; rotr90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/arraymath.jl#L244-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mapslices" href="#Base.mapslices"><code>Base.mapslices</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mapslices(f, A; dims)</code></pre><p>Transform the given dimensions of array <code>A</code> using function <code>f</code>. <code>f</code> is called on each slice of <code>A</code> of the form <code>A[...,:,...,:,...]</code>. <code>dims</code> is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if <code>dims</code> is <code>[1,2]</code> and <code>A</code> is 4-dimensional, <code>f</code> is called on <code>A[:,:,i,j]</code> for all <code>i</code> and <code>j</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = reshape(Vector(1:16),(2,2,2,2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; mapslices(sum, a, dims = [1,2])
1×1×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 10

[:, :, 2, 1] =
 26

[:, :, 1, 2] =
 42

[:, :, 2, 2] =
 58</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarray.jl#L1851-L1894">source</a></section><h2><a class="nav-anchor" id="组合-1" href="#组合-1">组合</a></h2><!-- ## Combinatorics --><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.invperm" href="#Base.invperm"><code>Base.invperm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">invperm(v)</code></pre><p>Return the inverse permutation of <code>v</code>. If <code>B = A[v]</code>, then <code>A == B[invperm(v)]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [2; 4; 3; 1];

julia&gt; invperm(v)
4-element Array{Int64,1}:
 4
 1
 3
 2

julia&gt; A = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];

julia&gt; B = A[v]
4-element Array{Char,1}:
 &#39;b&#39;
 &#39;d&#39;
 &#39;c&#39;
 &#39;a&#39;

julia&gt; B[invperm(v)]
4-element Array{Char,1}:
 &#39;a&#39;
 &#39;b&#39;
 &#39;c&#39;
 &#39;d&#39;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/combinatorics.jl#L164-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isperm" href="#Base.isperm"><code>Base.isperm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isperm(v) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>v</code> is a valid permutation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isperm([1; 2])
true

julia&gt; isperm([1; 3])
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/combinatorics.jl#L39-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.permute!-Tuple{Any,AbstractArray{T,1} where T}" href="#Base.permute!-Tuple{Any,AbstractArray{T,1} where T}"><code>Base.permute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">permute!(v, p)</code></pre><p>Permute vector <code>v</code> in-place, according to permutation <code>p</code>. No checking is done to verify that <code>p</code> is a permutation.</p><p>To return a new permutation, use <code>v[p]</code>. Note that this is generally faster than <code>permute!(v,p)</code> for large vectors.</p><p>See also <a href="#Base.invpermute!"><code>invpermute!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; permute!(A, perm);

julia&gt; A
4-element Array{Int64,1}:
 1
 4
 3
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/combinatorics.jl#L88-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.invpermute!" href="#Base.invpermute!"><code>Base.invpermute!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">invpermute!(v, p)</code></pre><p>Like <a href="#Base.permute!-Tuple{Any,AbstractArray{T,1} where T}"><code>permute!</code></a>, but the inverse of the given permutation is applied.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; invpermute!(A, perm);

julia&gt; A
4-element Array{Int64,1}:
 4
 1
 3
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/combinatorics.jl#L141-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse-Tuple{AbstractArray{T,1} where T}" href="#Base.reverse-Tuple{AbstractArray{T,1} where T}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reverse(v [, start=1 [, stop=length(v) ]] )</code></pre><p>Return a copy of <code>v</code> reversed from start to stop.  See also <a href="../iterators/#Base.Iterators.reverse"><code>Iterators.reverse</code></a> for reverse-order iteration without making a copy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Vector(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; reverse(A)
5-element Array{Int64,1}:
 5
 4
 3
 2
 1

julia&gt; reverse(A, 1, 4)
5-element Array{Int64,1}:
 4
 3
 2
 1
 5

julia&gt; reverse(A, 3, 5)
5-element Array{Int64,1}:
 1
 2
 5
 4
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1386-L1426">source</a><div><div><pre><code class="language-none">reverse(A; dims::Integer)</code></pre><p>Reverse <code>A</code> in dimension <code>dims</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; reverse(b, dims=2)
2×2 Array{Int64,2}:
 2  1
 4  3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/abstractarraymath.jl#L131-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverseind" href="#Base.reverseind"><code>Base.reverseind</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reverseind(v, i)</code></pre><p>Given an index <code>i</code> in <a href="#Base.reverse-Tuple{AbstractArray{T,1} where T}"><code>reverse(v)</code></a>, return the corresponding index in <code>v</code> so that <code>v[reverseind(v,i)] == reverse(v)[i]</code>. (This can be nontrivial in cases where <code>v</code> contains non-ASCII characters.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; r = reverse(&quot;Julia&quot;)
&quot;ailuJ&quot;

julia&gt; for i in 1:length(r)
           print(r[reverseind(&quot;Julia&quot;, i)])
       end
Julia</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/strings/basic.jl#L626-L643">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reverse!(v [, start=1 [, stop=length(v) ]]) -&gt; v</code></pre><p>In-place version of <a href="#Base.reverse-Tuple{AbstractArray{T,1} where T}"><code>reverse</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Vector(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; reverse!(A);

julia&gt; A
5-element Array{Int64,1}:
 5
 4
 3
 2
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b145832402429ee1c88709edb3e341067353d1b0/base/array.jl#L1449-L1474">source</a></section><footer><hr/><a class="previous" href="../strings/"><span class="direction">Previous</span><span class="title">Strings</span></a><a class="next" href="../parallel/"><span class="direction">Next</span><span class="title">Tasks</span></a></footer></article></body></html>
